{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Event: Down Under CTF 2024. Duration: 48hours Team: 418WeAreTeapots Website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public Thank you to team 418WeAreTeapots for taking this journey with me and commiting long hours over weekends: ImTheProblem samiam abi2050 betactf HakerSanta meowsite JamzSlime","title":"DownUnderCTF 2024 Writeups"},{"location":"decrypt_eval/","text":"Prologue \u00b6 Difficulty: easy Category: cryptography Solved: 197 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Decrypt then eval writeup"},{"location":"decrypt_eval/#prologue","text":"Difficulty: easy Category: cryptography Solved: 197 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"decrypt_eval/#my-struggle","text":"","title":"My struggle"},{"location":"decrypt_eval/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"dna/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 148 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"DNAdecay writeup"},{"location":"dna/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 148 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"dna/#my-struggle","text":"","title":"My struggle"},{"location":"dna/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"jmp_flag/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 71 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Jmp flag writeup"},{"location":"jmp_flag/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 71 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"jmp_flag/#my-struggle","text":"","title":"My struggle"},{"location":"jmp_flag/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"number_mashing/","text":"My second writeup for Down Under CTF 2024. Feedback is much appreciated. Prologue \u00b6 Difficulty: beginner Category: reverse engineering Solved: 299 Description Mash your keyboard numpad in a specific order and a flag might just pop out! Input files: number_mashing NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Check what type of file we got: 1 2 3 4 5 6 7 8 9 10 $ file number-mashing number-mashing: ELF 64 -bit LSB pie executable, # 64bit ARM aarch64, # ARM machine need to run version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID [ sha1 ]= ab93f9bc0ec8c3d321da1b7e954e739e13ee8ab1, for GNU/Linux 3 .7.0, not stripped # likely a readable code can be extracted I didn't have arm environment ready at that moment, so won't be able to run the binary locally. Instead, lets fire up ghidra and try to understand the code, as mentioned above it should make a lot of sense given binary is not stripped. original ghydra output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 undefined8 main ( void ) { local_8 = ___stack_chk_guard ; setvbuf ( _stdout ,( char * ) 0x0 , 2 , 0 ); setvbuf ( _stdin ,( char * ) 0x0 , 2 , 0 ); printf ( \"Give me some numbers: \" ); __isoc99_scanf ( \"%d %d\" , & local_11c , & local_118 ); if ((( local_11c == 0 ) || ( local_118 == 0 )) || ( local_118 == 1 )) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_114 = 0 ; if ( local_118 != 0 ) { local_114 = local_11c / local_118 ; } if ( local_114 != local_11c ) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_110 = fopen ( \"flag.txt\" , \"r\" ); fread ( & local_108 , 1 , 0x100 , local_110 ); printf ( \"Correct! %s \\n \" , & local_108 ); if ( local_8 - ___stack_chk_guard != 0 ) { /* WARNING: Subroutine does not return */ __stack_chk_fail ( & __stack_chk_guard , 0 , 0 , local_8 - ___stack_chk_guard ); } return 0 ; } We can see print, scanf, then some calculations. Cleaned version with extra comments: cleaned source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> void main () { int first , second ; printf ( \"Give me some numbers: \" ); scanf ( \"%d %d\" , & first , & second ); # read two numbers : first and second # check that first is not 0 and second is no 0 nor 1 if ((( first == 0 ) || ( second == 0 )) || ( second == 1 )) { puts ( \"Nope!\" ); exit ( 1 ); } int res = first / second ; # divide if ( res != first ) { # check that result is equal to first number puts ( \"Nope!\" ); exit ( 1 ); } puts ( \"Here is your flag flag!\" ); } Now the task is clear: we are looking for two numbers such that when one is divided by the other the result is equal to dividend. Usually we would achieve it with by having second number as one 4 / 1 = 4 , but extra condition in the code that we should use 1. Quick check with my times table confirmed that calculus won't help us here. Instead, we want to take advantage of overflow. Goal is to find such numbers that result won't fit into the register and when truncated will be equal to dividend. Its quite easy to do with multiplication, for example for 1 byte numbers: 0x10 * 0x11 = 0x110 , which is truncated to 0x10 . To experiment locally I've compiled the code above gcc -o number-mashing number-mashing.c . After a bit trial and error within constraints that second cannot be large number, in fact only -1 makes sense (and maybe 2 if we treat divide by two as shift right where flag bit is carried). And first number should have top bits sets, so they will be truncated by flag bit. Testing with following inputs -2147483648 -1 gives us something interesting: 1 2 3 $ ./number-mashing Give me some numbers: -2147483648 -1 zsh: floating point exception ./number-mashing On x86 architecture idiv assembly instruction is used, quick google idiv floating point exception bring us to stackoverflow . idiv will raise an exception in two cases: You divide by zero The division result is not in the range that can be represented by the eax register Indeed, range for 4 byte number is from -2147483648 to 2147483647, so result of -2147483648 / -1 = 2147483648 doesn't fit in the range above, hence we got error. On arm architecture sdiv instruction is used, it doesn't raise exception, instead carry flag is set in cpsr register. Connecting to the challenge server and submitting two numbers got us the flag. Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Number mashing"},{"location":"number_mashing/#prologue","text":"Difficulty: beginner Category: reverse engineering Solved: 299 Description Mash your keyboard numpad in a specific order and a flag might just pop out! Input files: number_mashing NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"number_mashing/#my-struggle","text":"Check what type of file we got: 1 2 3 4 5 6 7 8 9 10 $ file number-mashing number-mashing: ELF 64 -bit LSB pie executable, # 64bit ARM aarch64, # ARM machine need to run version 1 ( SYSV ) , dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID [ sha1 ]= ab93f9bc0ec8c3d321da1b7e954e739e13ee8ab1, for GNU/Linux 3 .7.0, not stripped # likely a readable code can be extracted I didn't have arm environment ready at that moment, so won't be able to run the binary locally. Instead, lets fire up ghidra and try to understand the code, as mentioned above it should make a lot of sense given binary is not stripped. original ghydra output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 undefined8 main ( void ) { local_8 = ___stack_chk_guard ; setvbuf ( _stdout ,( char * ) 0x0 , 2 , 0 ); setvbuf ( _stdin ,( char * ) 0x0 , 2 , 0 ); printf ( \"Give me some numbers: \" ); __isoc99_scanf ( \"%d %d\" , & local_11c , & local_118 ); if ((( local_11c == 0 ) || ( local_118 == 0 )) || ( local_118 == 1 )) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_114 = 0 ; if ( local_118 != 0 ) { local_114 = local_11c / local_118 ; } if ( local_114 != local_11c ) { puts ( \"Nope!\" ); /* WARNING: Subroutine does not return */ exit ( 1 ); } local_110 = fopen ( \"flag.txt\" , \"r\" ); fread ( & local_108 , 1 , 0x100 , local_110 ); printf ( \"Correct! %s \\n \" , & local_108 ); if ( local_8 - ___stack_chk_guard != 0 ) { /* WARNING: Subroutine does not return */ __stack_chk_fail ( & __stack_chk_guard , 0 , 0 , local_8 - ___stack_chk_guard ); } return 0 ; } We can see print, scanf, then some calculations. Cleaned version with extra comments: cleaned source code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> void main () { int first , second ; printf ( \"Give me some numbers: \" ); scanf ( \"%d %d\" , & first , & second ); # read two numbers : first and second # check that first is not 0 and second is no 0 nor 1 if ((( first == 0 ) || ( second == 0 )) || ( second == 1 )) { puts ( \"Nope!\" ); exit ( 1 ); } int res = first / second ; # divide if ( res != first ) { # check that result is equal to first number puts ( \"Nope!\" ); exit ( 1 ); } puts ( \"Here is your flag flag!\" ); } Now the task is clear: we are looking for two numbers such that when one is divided by the other the result is equal to dividend. Usually we would achieve it with by having second number as one 4 / 1 = 4 , but extra condition in the code that we should use 1. Quick check with my times table confirmed that calculus won't help us here. Instead, we want to take advantage of overflow. Goal is to find such numbers that result won't fit into the register and when truncated will be equal to dividend. Its quite easy to do with multiplication, for example for 1 byte numbers: 0x10 * 0x11 = 0x110 , which is truncated to 0x10 . To experiment locally I've compiled the code above gcc -o number-mashing number-mashing.c . After a bit trial and error within constraints that second cannot be large number, in fact only -1 makes sense (and maybe 2 if we treat divide by two as shift right where flag bit is carried). And first number should have top bits sets, so they will be truncated by flag bit. Testing with following inputs -2147483648 -1 gives us something interesting: 1 2 3 $ ./number-mashing Give me some numbers: -2147483648 -1 zsh: floating point exception ./number-mashing On x86 architecture idiv assembly instruction is used, quick google idiv floating point exception bring us to stackoverflow . idiv will raise an exception in two cases: You divide by zero The division result is not in the range that can be represented by the eax register Indeed, range for 4 byte number is from -2147483648 to 2147483647, so result of -2147483648 / -1 = 2147483648 doesn't fit in the range above, hence we got error. On arm architecture sdiv instruction is used, it doesn't raise exception, instead carry flag is set in cpsr register. Connecting to the challenge server and submitting two numbers got us the flag.","title":"My struggle"},{"location":"number_mashing/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"pac_shell/","text":"Prologue \u00b6 Difficulty: easy Category: binary exploitation Solved: 55 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Pac shell writeup"},{"location":"pac_shell/#prologue","text":"Difficulty: easy Category: binary exploitation Solved: 55 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"pac_shell/#my-struggle","text":"","title":"My struggle"},{"location":"pac_shell/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"rusty/","text":"Prologue \u00b6 Difficulty: easy Category: reverse engineering Solved: 81 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Rusty vault writeup"},{"location":"rusty/#prologue","text":"Difficulty: easy Category: reverse engineering Solved: 81 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"rusty/#my-struggle","text":"","title":"My struggle"},{"location":"rusty/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"shufflebox/","text":"Down Under CTF 2024 is the first CTF I've participated in. Our team did very well. This is writeup for one of the simpler challenges I've solved. Feedback is really, really appreciated. Prologue \u00b6 Difficulty: beginner Category: cryptography Solved: 582 Description I've learned that if you shuffle your text, it's elrlay hrda to tlle htaw eht nioiglra nutpi aws. Find the text censored with question marks in output_censored.txt and surround it with DUCTF{}. Input files: shufflebox.py 1 2 3 4 5 6 7 8 9 10 11 12 import random PERM = list ( range ( 16 )) random . shuffle ( PERM ) def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): line = line . strip () print ( line , '->' , apply_perm ( line )) output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 First things first - review source code of the script that ciphers data. Explanation for relevant parts of the code added as comments: shuffle.py with comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PERM = list ( range ( 16 )) # create list of 16 elements 0, 1, 2, 3 ... 16 random . shuffle ( PERM ) # shuffle elements of the list in a random order, so now we have something like 15, 3, 1, 6 ... # key tranformation logic # PERM shuffle list is used as array of indices # For example if PERM was a list of 4 elements [2, 0, 3, 1] # then result string will first output charcter 2 then 0 and so on, ie 'abcd' -> 'cadb' def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): # for each line of input apply transformation and print input and output line = line . strip () print ( line , '->' , apply_perm ( line )) Import note to make is that internal state of the cipher algorithm doesn't change and there is no nonce. In other words if we can infer PERM list from one line, we can recover all other inputs. Now that we understand how cipher algorithm works, lets review output file: output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud Looking at the first line we immediately spot the problem - there are 4 'a' in the input so we can't immediately tell where it was. Based on the first line aaaabbbbccccdddd -> ccaccdabdbdbbada , first character is moved in one of the following positions: [0] -> [2, 6, 13, 15] Given all rows are transformed exactly the same, we can use second row to narrow down positions of the first character: abcdabcdabcdabcd -> bcaadbdcdbcdacab : first character is moved into one of the following positions: [0] -> [2, 3, 12, 14] Now we can compare this two lists and see that only value 2 is present in both. Hence, first character of input is third character of output. Ie our answer will start with u . Although this problem can be solved by hand, I wrote a short stripe to print out all possible positions for each character of the input (although we were lucky with first character and found exact position, it is possible that for some positions we may have several candidates). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 [2] 1 [15] 2 [13] 3 [6] 4 [12] 5 [9] 6 [7] 7 [11] 8 [3] 9 [0] 10 [1] 11 [4] 12 [14] 13 [5] 14 [10] 15 [8] This means that character 0 of answer is owuwspdgrtejiiud[2] , character 1 is owuwspdgrtejiiud[1] and so on. Following short script prints out the answer: 1 2 3 challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] print ( resolved_positions ) challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Shufflebox"},{"location":"shufflebox/#prologue","text":"Difficulty: beginner Category: cryptography Solved: 582 Description I've learned that if you shuffle your text, it's elrlay hrda to tlle htaw eht nioiglra nutpi aws. Find the text censored with question marks in output_censored.txt and surround it with DUCTF{}. Input files: shufflebox.py 1 2 3 4 5 6 7 8 9 10 11 12 import random PERM = list ( range ( 16 )) random . shuffle ( PERM ) def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): line = line . strip () print ( line , '->' , apply_perm ( line )) output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"shufflebox/#my-struggle","text":"First things first - review source code of the script that ciphers data. Explanation for relevant parts of the code added as comments: shuffle.py with comments 1 2 3 4 5 6 7 8 9 10 11 12 13 14 PERM = list ( range ( 16 )) # create list of 16 elements 0, 1, 2, 3 ... 16 random . shuffle ( PERM ) # shuffle elements of the list in a random order, so now we have something like 15, 3, 1, 6 ... # key tranformation logic # PERM shuffle list is used as array of indices # For example if PERM was a list of 4 elements [2, 0, 3, 1] # then result string will first output charcter 2 then 0 and so on, ie 'abcd' -> 'cadb' def apply_perm ( s ): assert len ( s ) == 16 return '' . join ( s [ PERM [ p ]] for p in range ( 16 )) for line in open ( 0 ): # for each line of input apply transformation and print input and output line = line . strip () print ( line , '->' , apply_perm ( line )) Import note to make is that internal state of the cipher algorithm doesn't change and there is no nonce. In other words if we can infer PERM list from one line, we can recover all other inputs. Now that we understand how cipher algorithm works, lets review output file: output_censored.txt 1 2 3 aaaabbbbccccdddd -> ccaccdabdbdbbada abcdabcdabcdabcd -> bcaadbdcdbcdacab ???????????????? -> owuwspdgrtejiiud Looking at the first line we immediately spot the problem - there are 4 'a' in the input so we can't immediately tell where it was. Based on the first line aaaabbbbccccdddd -> ccaccdabdbdbbada , first character is moved in one of the following positions: [0] -> [2, 6, 13, 15] Given all rows are transformed exactly the same, we can use second row to narrow down positions of the first character: abcdabcdabcdabcd -> bcaadbdcdbcdacab : first character is moved into one of the following positions: [0] -> [2, 3, 12, 14] Now we can compare this two lists and see that only value 2 is present in both. Hence, first character of input is third character of output. Ie our answer will start with u . Although this problem can be solved by hand, I wrote a short stripe to print out all possible positions for each character of the input (although we were lucky with first character and found exact position, it is possible that for some positions we may have several candidates). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 0 [2] 1 [15] 2 [13] 3 [6] 4 [12] 5 [9] 6 [7] 7 [11] 8 [3] 9 [0] 10 [1] 11 [4] 12 [14] 13 [5] 14 [10] 15 [8] This means that character 0 of answer is owuwspdgrtejiiud[2] , character 1 is owuwspdgrtejiiud[1] and so on. Following short script prints out the answer: 1 2 3 challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" ) Full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 in1 = \"aaaabbbbccccdddd\" out1 = \"ccaccdabdbdbbada\" in2 = \"abcdabcdabcdabcd\" out2 = \"bcaadbdcdbcdacab\" resolved_positions = [ - 1 ] * 16 for i in range ( 16 ): # iterate over each position 0..15 and analyze what a resulting possible positions (aka candidates) candidates = [] for j in range ( 16 ): # if input character at position i is same as output character at position j for both lines # then this position j is one of candidate shuffles if out1 [ j ] == in1 [ i ] and out2 [ j ] == in2 [ i ]: candidates . append ( j ) print ( i , candidates ) if len ( candidates ) == 1 : # if number of candidates is 1, then we uniquely identifies transformation and can store it resolved_positions [ i ] = candidates [ 0 ] print ( resolved_positions ) challenge = \"owuwspdgrtejiiud\" for i in range ( 16 ): print ( challenge [ resolved_positions [ i ]], end = \"\" )","title":"My struggle"},{"location":"shufflebox/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"sign_in/","text":"Prologue \u00b6 Difficulty: easy Category: binary exploitation Solved: 95 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Sign in writeup"},{"location":"sign_in/#prologue","text":"Difficulty: easy Category: binary exploitation Solved: 95 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"sign_in/#my-struggle","text":"","title":"My struggle"},{"location":"sign_in/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"sssshhhh/","text":"Prologue \u00b6 Difficulty: beginner Category: reverse engineering Solved: 81 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"sssshhhh writeup"},{"location":"sssshhhh/#prologue","text":"Difficulty: beginner Category: reverse engineering Solved: 81 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"sssshhhh/#my-struggle","text":"","title":"My struggle"},{"location":"sssshhhh/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"transmissions/","text":"Prologue \u00b6 Difficulty: beginner Category: miscellaneous Solved: 275 Description Those monsters! They've kidnapped the Quokkas! Who in their right mind would capture those friendly little guys.. We've managed to intercept a CCIR476 transmission from the kidnappers, we think it contains the location of our friends! Can you help us decode it? We managed to decode the first two characters as '##' Input files: encoding.txt 101101001101101101001110100110110101110100110100101101101010110101110010110100 101110100111001101100101101101101000111100011110011011010101011001011101101010 010111011100100011110101010110110101011010111001011010110100101101101010110101 101011001011010011101110001101100101110101101010110011011100001101101101101010 101101101000111010110110010111010110101100101100110111101000101011101110001101 101101001010111001011101110001010111001011100011011 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Quick google CCIR476 leads us to wiki page that explains that CCIR476 is a character enconding used in radio data protocol. So seems like we should start by decoding message. Article itself is not too friendly and doesn't explain much (too many technical words without definition for my liking), but there is important bit it stats that CCIR 476 is a 7-bit encoding. This allows us quickly test if our input is indeed CCID476 message without investing hours in the wrong direction: length of input is 441 which is exactly 63 7bit words. Looks promising! Second link in google is https://blog.gcwizard.net/manual/en/ccitt-codes/08-what-is-ccir-476/ Which contains table that can be used for decoding: So in first version I created alphabet with all characters I can understand and left others ( CR , LTRS , FIGS ) empty: Interation 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"\" , \"1011010\" : \"\" , } input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for i in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ i : i + 7 ] # take 7 characters starting at i print ( letters [ word ], end = \"\" ) # print letter from alphabet that corresponds to the sequence The result is looking very promising, I can even read the sentence: 1 HHTHE QUPKKRSS ARE HELD QN FRCQLITY HQQOQQF But some letters are wrong, and also according to description of the challenge result should start with ## . So, how can we get from HH to ## ? Notice from encoding table has many columns and 1101001 is H in letters case, but # in US TTYs (whatever that means). Probably ignored so far characters CR , LTRS and FIGS could be helpful. Explanation is very obvious, but on the day it took quite a lot of trial and errors: LTRS - switches decoding into letters mode (ie after LTRS symbols all characters are letters until FIGS is encountered) FIGS - switching decoding into figures mode (ie all characters from now will be symbols until LTRS is encountered) Second alphabet added, slightly updated decoding logic: full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } figures = { \"1010011\" : '$' , \"1000111\" : \"-\" , \"1110001\" : \"9\" , \"1010110\" : \"3\" , \"1011100\" : \" \" , \"0011101\" : \":\" , \"0011011\" : \"!\" , \"0110101\" : \"&\" , \"1101001\" : \"#\" , \"1100101\" : \")\" , \"1001101\" : \"8\" , \"0010111\" : \"`\" , \"0011110\" : \"(\" , \"0111001\" : \".\" , \"1011001\" : \",\" , \"0101101\" : \"0\" , \"0101110\" : '1' , \"1010101\" : \"4\" , \"1001011\" : \"'\" , \"1110100\" : \"5\" , \"1001110\" : \"7\" , \"0111100\" : \";\" , \"0100111\" : \"2\" , \"0111010\" : \"/\" , \"0101011\" : \"6\" , \"1100011\" : \" \\\" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } mode = figures # variable to switch between letters and figures alphabets input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for w in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ w : w + 7 ] # take 7 characters starting at i if mode [ word ] == \"FIGS\" : mode = figures elif mode [ word ] == \"LTRS\" : mode = letters else : print ( mode [ input [ w : w + 7 ]], end = \"\" ) # print letter from alphabet that corresponds to the sequence The only thing not mentioned before is I used ' instead of BELL character because its not clear what that one means and single quote grammatically made sense. Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Intercepted transmissions"},{"location":"transmissions/#prologue","text":"Difficulty: beginner Category: miscellaneous Solved: 275 Description Those monsters! They've kidnapped the Quokkas! Who in their right mind would capture those friendly little guys.. We've managed to intercept a CCIR476 transmission from the kidnappers, we think it contains the location of our friends! Can you help us decode it? We managed to decode the first two characters as '##' Input files: encoding.txt 101101001101101101001110100110110101110100110100101101101010110101110010110100 101110100111001101100101101101101000111100011110011011010101011001011101101010 010111011100100011110101010110110101011010111001011010110100101101101010110101 101011001011010011101110001101100101110101101010110011011100001101101101101010 101101101000111010110110010111010110101100101100110111101000101011101110001101 101101001010111001011101110001010111001011100011011 NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"transmissions/#my-struggle","text":"Quick google CCIR476 leads us to wiki page that explains that CCIR476 is a character enconding used in radio data protocol. So seems like we should start by decoding message. Article itself is not too friendly and doesn't explain much (too many technical words without definition for my liking), but there is important bit it stats that CCIR 476 is a 7-bit encoding. This allows us quickly test if our input is indeed CCID476 message without investing hours in the wrong direction: length of input is 441 which is exactly 63 7bit words. Looks promising! Second link in google is https://blog.gcwizard.net/manual/en/ccitt-codes/08-what-is-ccir-476/ Which contains table that can be used for decoding: So in first version I created alphabet with all characters I can understand and left others ( CR , LTRS , FIGS ) empty: Interation 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"\" , \"1011010\" : \"\" , } input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for i in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ i : i + 7 ] # take 7 characters starting at i print ( letters [ word ], end = \"\" ) # print letter from alphabet that corresponds to the sequence The result is looking very promising, I can even read the sentence: 1 HHTHE QUPKKRSS ARE HELD QN FRCQLITY HQQOQQF But some letters are wrong, and also according to description of the challenge result should start with ## . So, how can we get from HH to ## ? Notice from encoding table has many columns and 1101001 is H in letters case, but # in US TTYs (whatever that means). Probably ignored so far characters CR , LTRS and FIGS could be helpful. Explanation is very obvious, but on the day it took quite a lot of trial and errors: LTRS - switches decoding into letters mode (ie after LTRS symbols all characters are letters until FIGS is encountered) FIGS - switching decoding into figures mode (ie all characters from now will be symbols until LTRS is encountered) Second alphabet added, slightly updated decoding logic: full solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 letters = { \"1000111\" : \"A\" , \"1110010\" : \"B\" , \"0011101\" : \"C\" , \"1010011\" : 'D' , \"1010110\" : \"E\" , \"0011011\" : \"F\" , \"0110101\" : \"G\" , \"1101001\" : \"H\" , \"1001101\" : \"I\" , \"0010111\" : \"J\" , \"0011110\" : \"K\" , \"1100101\" : \"L\" , \"0111001\" : \"M\" , \"1011001\" : \"N\" , \"1110001\" : \"O\" , \"0101101\" : \"P\" , \"0101110\" : 'Q' , \"1010101\" : \"R\" , \"1001011\" : \"S\" , \"1110100\" : \"T\" , \"1001110\" : \"U\" , \"0111100\" : \"V\" , \"0100111\" : \"W\" , \"0111010\" : \"X\" , \"0101011\" : \"Y\" , \"1100011\" : \"Z\" , \"1011100\" : \" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } figures = { \"1010011\" : '$' , \"1000111\" : \"-\" , \"1110001\" : \"9\" , \"1010110\" : \"3\" , \"1011100\" : \" \" , \"0011101\" : \":\" , \"0011011\" : \"!\" , \"0110101\" : \"&\" , \"1101001\" : \"#\" , \"1100101\" : \")\" , \"1001101\" : \"8\" , \"0010111\" : \"`\" , \"0011110\" : \"(\" , \"0111001\" : \".\" , \"1011001\" : \",\" , \"0101101\" : \"0\" , \"0101110\" : '1' , \"1010101\" : \"4\" , \"1001011\" : \"'\" , \"1110100\" : \"5\" , \"1001110\" : \"7\" , \"0111100\" : \";\" , \"0100111\" : \"2\" , \"0111010\" : \"/\" , \"0101011\" : \"6\" , \"1100011\" : \" \\\" \" , \"1111000\" : \"\" , \"0110110\" : \"FIGS\" , \"1011010\" : \"LTRS\" , } mode = figures # variable to switch between letters and figures alphabets input = \"101101001101101101001110100110110101110100110100101101101010110101110010110100101110100111001101100101101101101000111100011110011011010101011001011101101010010111011100100011110101010110110101011010111001011010110100101101101010110101101011001011010011101110001101100101110101101010110011011100001101101101101010101101101000111010110110010111010110101100101100110111101000101011101110001101101101001010111001011101110001010111001011100011011\" for w in range ( 0 , len ( input ), 7 ): # generate sequence 0, 7, 14 ... 441 word = input [ w : w + 7 ] # take 7 characters starting at i if mode [ word ] == \"FIGS\" : mode = figures elif mode [ word ] == \"LTRS\" : mode = letters else : print ( mode [ input [ w : w + 7 ]], end = \"\" ) # print letter from alphabet that corresponds to the sequence The only thing not mentioned before is I used ' instead of BELL character because its not clear what that one means and single quote grammatically made sense.","title":"My struggle"},{"location":"transmissions/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"vector/","text":"Prologue \u00b6 Difficulty: beginner Category: binary exploitation Solved: 239 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Vector overflow writeup"},{"location":"vector/#prologue","text":"Difficulty: beginner Category: binary exploitation Solved: 239 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"vector/#my-struggle","text":"","title":"My struggle"},{"location":"vector/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"},{"location":"yawa/","text":"Prologue \u00b6 Difficulty: beginner Category: binary exploitation Solved: 184 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure. My struggle \u00b6 Epilogue \u00b6 Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Yawa writeup"},{"location":"yawa/#prologue","text":"Difficulty: beginner Category: binary exploitation Solved: 184 Description Input files: encoding.txt NB: Following indices bases system is used to avoid ambiguity. Whenever element of a collection is referenced by number , 0-based index implied. Ie, element 0 of list [1, 2, 4, 8, 16] is 1 , Element 3 is 8 . When element is reference in explanation with word (first, third...), 1-based system is implied. Ie, first character of string Hello World! is H , fifth is o . Solution code was redacted for readability purposes. Due to time pressure during the competition I was using a lot of one-letter variables and questionable code structure.","title":"Prologue"},{"location":"yawa/#my-struggle","text":"","title":"My struggle"},{"location":"yawa/#epilogue","text":"Official website: https://downunderctf.com/ Official writeups: https://github.com/DownUnderCTF/Challenges_2024_Public","title":"Epilogue"}]}